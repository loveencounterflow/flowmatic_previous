

RANDOM SNIPPETS
############################################################################################################

To quote a function without calling the function::

   length-of°
   length-of*

Rejected for this purpose::

   length-of
   length-of%
   length-of&
   length-of+
   length-of-
   length-of:
   length-of^
   length-of| # too similar to ``length-of |``
  %length-of
  &length-of
  *length-of
  +length-of
  -length-of
  :length-of
  ^length-of
  |length-of
  °length-of

  do-it:   x, y, | <-> join [ x, y, ]

  do-it: ( x, y, ) <-> join [ x, y, ]

  12.34€
  12kg
  3s
  3000µs

Security
############################################################################################################


The Stages of Acquisition
------------------------------------------------------------------------------------------------------------

In addition to the Rules of Acquisition, the Ferengi recognize five Stages of Acquisition:

(1) Infatuation:   An unreasoning love or attraction: "I want it."
(2) Justification: Moral excuse used to explain: "I must have it!"
(3) Appropriation: To take to one's self in exclusion of others: "IT'S MINE AT LAST!"
(4) Obsession:     A compulsive or irrational preoccupation: "My Precious!"
(5) Resale:        The action of selling something previously bought: "Make me an offer."

In order to obtain a capabilities-secure system, the Three Stages of Acquisition have to be followed:

(1) By Creation.
(2) By Construction.
(3) By Introduction.

Specifically, it must not be possible to be able to inspect an object by just knowing its name—JavaScript is
inherently capabilities-insecure because of the global object.

"If references can only be obtained by Creation, Construction, or Introduction, then you *may* have a secure
system. If references can be obtained in any other way, you do not have a safe system."

Lazy Security
------------------------------------------------------------------------------------------------------------

http://www.youtube.com/watch?v=eL5o4PFuxTY

Four Rules of Lazy Security
............................................................................................................

1)  POLA, the Principle of Least Authority (a.k.a. Principle of Least Privilege; Don't Give It If they Don't
    Need It; Don't Pass Unneeded Arguments; Maximum Business Opportunity)

    http://www.youtube.com/watch?feature=player_detailpage&v=eL5o4PFuxTY#t=252s


Calling without Parentheses
############################################################################################################

In $LSD, there are no parentheses for function calls::

  foo x, y, z

It *is* possible to use parentheses for clarity or algebraic precedence in any expression, and since the
arguments of a function call is a series of expressions, which itself is an expression again, these are no
exceptions, so you can write ::

  foo x, ( y + 3 ), z

and


but *not*

  ###DONT###
  foo( x, ( y + 3 ), z )

which is a syntax error, the space behind the function invocation ``foo`` being required by the grammar. One
more alternative is to embrace all of the function call::


  ( foo x, y, z ) * ( gnu a, b )

which sometimes produces quite readable code.

When i write in CoffeeScript, i am tremendously enjoying my newly gained freedom from dispensible brackets,
brackets that have bothered me in Python. I could never program in Lisp, as i can't bear the number of
parentheses::

  (defun ldap-users ()
    (let ((people (make-hash-table :test 'equal)))
      (ldap:dosearch (ent (ldap:search *ldap* "(&(telephonenumber=*) (cn=*))"))
                     (let ((mail        (car (ldap:attr-value ent 'mail)))
                           (uid         (car (ldap:attr-value ent 'uid)))
                           (name        (car (ldap:attr-value ent 'cn)))
                           (phonenumber (car (ldap:attr-value ent 'telephonenumber))))
                        (setf (gethash uid people)
                              (list mail name phonenumber))))
      people))

Of course, there is the side-effect that while many programmers do strive to produce code with meaningful
indentation, their labor gets completely lost on a language that does not honor formatting and treats all
code as one long linear string of characters.

JavaScript, too, has by far more braces, brackets and parentheses than what i am willing to tolerate. Of
course, it is not the braces as such that are the problem---Ruby uses ``end`` a lot to delineate blocks of
code, a long standing tradition in coding. Notice the leading whitespace in this sample is purely decorative
and does not influence the interpretation of the code in any way::

  ###RUBY###

  class Employee

    def etype
      if @position == "CEO" || @position == "CFO"
        "executive"
      else
        "staff"
      end             # (*)
    end               # (**)

    def initialize(fname, lname, position)
      super(fname,lname)
      @position = position
    end

    def to_s
      super + ", #@position"
    end

  end


This is in some respects somewhat better looking than braces, except you ``end`` up writing ``end`` all day,
but on the other hand most text editors won't give you the level of assistance they offer for identifying
matching braces. The real bad thing is that if you forget any single ``end`` then Ruby will complain with
one of its cryptic error messages and likely point to the end of the file as being the problematic spot:
delete the line marked ``(*)`` and run the example, and Ruby will answer with, like, ``/tmp/foo.rb:18:
syntax error, unexpected $end,  expecting kEND`` which is gibberish and a dozen lines off the mark. It can
easily be hundreds off lines off the mark, so happy hunting. Even better: If you happened to have
erroneously put spurious ``end`` at the end of file, you will get the exactly same error message! That's
right, Ruby won't ever bother to tell you whether you have too many or too few ``end`` statements in your
code. This error message is hardly better than segfaulting! Again even better: take the code shown and move
the line marked ``(**)`` to the very end of the file. This completely changes the meaning of the code, but
does get accepted as syntactically correct. You end up with code that looks a lot like meaning something
but it actually means something radically different.

In a way, code that uses decorative leading whitespace in a language that doesn't bother is highly
problematic and can be counterproductive, as the visual clue afforded by indentation is so strong that
readers are easily led to assume a meaning that the code does not have.

One of the few places where parentheses do bother me in CoffeeScript is when i call a function without
arguments. Then, parentheses are obligatory, and omitting them will produce a reference to the function. I
consider this an understandable and conventionally sanctioned violation of the rule of least surprise, so
if ``f`` is a function, writing ``f`` with no arguments will call ``f`` as does ``f x`` with arguments.


With No Braces, How Many Arguments does a Function See?
------------------------------------------------------------------------------------------------------------

If i remember correctly, one of the concerns in the Python developers community surrounding the question of
whether to allow bracket-less function calls was the issue of how to delineate the boundaries of sets of
arguments in nested function calls. If we write ::

  ###PYTHON###

  foo( bar( x ), y, z )

then it is unambigous that ``bar`` gets ``x`` and ``foo`` gets (the result of ``bar( x )`` and) ``y`` and
``z``. But if we write

  ###PYTHON###

  foo bar x, y, z

that clarity is gone. This is a good example for how theory can be misleading in lack of experience: I used
to wonder about this question a lot and imagined several solutions. Today i believe the simplest rule which
'just works' in the majority of usecases must be CoffeeScript's rule: The winner takes it all, and in this
case the last functioned mentioned is the happy guy. So the above line is going to mean ::

  ###PYTHON###

  foo( bar( x, y, z ) )

to the CoffeeScript interpreter. This works surprisingly well in a great lot of use cases, and since the
rule is so easy to understand and implement, there are rather few cases in my as yet short but intense
contact with CoffeeScript. I have been and still am building a rather substantial library of CoffeeScript
code to deal with myriads of diverse little tasks and constantly switch beetween the terminal to run code
and the texteditor to write new and correct old code. Believe me, i do get to see a lot of silent failures,
stack traces (now in color! with source excerpts! yay!), surprising behaviors due to the asynchronous nature
of  NodeJS, everything. I write lots of ``log this; log that`` code, and a lot of ``log white a; log green
b``  and so on, because the colors help to visually grasp the output. Did i ever misplace arguments in
nested  function calls? Yes, quite a few times. But no comparison with all the other stupid blunders i
committed.

One place where misplaced function arguments *did* bother me too often was the ``log`` command. I used to
write ``log rpr strange_object`` a lot, since ``rpr`` calls the NodeJS ``util.inspect`` facility to give a
meaningful output insted of the nonsensical ``[object Object]`` that JavaScript thinks is a polite way to
answer. It worked, but when you want to print more than one thing as in ``log rpr foo, rpr bar, rpr baz``
then the first ``rpr`` gets fed with what ``rpr bar, rpr baz`` returns, which is not good. I have since
integrated ``rpr`` into ``log`` and the issue is greatly mitigated already.

In my experience, when function nesting becomes an issue for argument allocation, then it is likely the code
was too convoluted to boot. You *can* write ::

  a = gnu ( baz ( bar foo 42 ), 108 ), 7

but often it is better to say ::

  astrumfication  = barred frob_of 42
  bazzes          = bazzes_of astrumfication, 108
  ascension       = gnullificate bazzes, 7

and marvel at how the serialization of the subsequent calls and the usage of meaningful names improves your
code---one trouble with nested function calls being, after all, that all the intermediary results remain
anonymous and are not available for console output. Logging and naming are both is paramount.



###SYNTAX###

::

  query name: 'foo', on-error: error-handler|, on-result: result-handler|

  hoo gnu foo u, v, w

  h ( g ( f u ), v ), w

  hoo gnu foo u | v | w

  hoo gnu foo u, v | w, x | z


Function Call Conventions: A Look at Python, Ruby, and Lua
------------------------------------------------------------------------------------------------------------

There has been much discussion around optional call parentheses in the Python community for years; but as of
version 3.2, nothing has come of it. Quite the opposite, since ``print`` has been demoted from the status of
a statement to that of an ordinary function, the ratio of unbracketed statements to bracketed calls has been
somewhat shifted in favor of bracketed constructs. One more observation in that language that is relevant
here is that Python does have 'properties'. The syntax of properties makes them look like ordinary object
attributes, but behind the scenes, a handler method gets called each time they are used, which  means that
in Python, it *is* possible to call some functions---which is quite different from CoffeeScript, which makes
brackets optional for function calls *with* arguments but requires them for calls *without* arguments. (One
more restriction of properties is that there is absolutely no way to use them without calling them on their
possessing object, so ``time.date`` might give back another current datetime whenever it gets used, but
you cannot say just ``get_date = time.date; print( get_date )`` to call a property; ``get_date`` will remain
constant, which is a necessary outcome of Python's overall design).

While we are at comparing languages, let's throw in two more popular ones, namely Ruby and Lua. Ruby allows
to call functions without parentheses, even when there are no arguments. It is clear that there must be a
way to obtain a function reference (which, in Python, is quite straightforward: ``f`` is the method, ``f()``
calls it), and given the amount of surprising shortcuts that this language has been designed to contain,
obtaining a function reference is amazingly cumbersome---you have to call the very method called ``method``
on the object and pass in the name of the method you want to access::

  ###RUBY###

  class Demo
    def helo()
      ...
    end
  end

  demo  = Demo.new
  helo  = demo.method 'helo'

...which is awkward and awful rather than awesome. Not clear what to do with module-global functions, but
i'm almost sure there is some &%$§* trick to do that. Yuck.

So i went to see whether Lua has anything interesting to offer that we can learn from. I had been playing
around with that language a decade ago or so when looking for my next favorite language (that then turned
out to be Python, which i consider a lucky choice, given the alternatives back then). It had almost become
Lua, but man am i happy it never did. Consider this (phrases gleaned from wikibooks and the official Lua
site; edited):

* Function arguments are normally enclosed in parentheses; there may be spaces between the function name and
  the opening bracket.

* If the function call has only one argument and this is either a string or a table constructor, then the
  parentheses can be omitted.

That second rule here is a good example of surprising design. Not only the number of arguments is
restricted, but their *types* are used to decide which syntax is legal and which is not. That's plain crazy!
What about integers with a value of 21 and over, but only on Sundays? Crazy!

It is a little offtopic indeed, but just to warn readers and make them aware of the level of BS that goes
into programming language design, here are more Lua rules around function calling. If you've never concerned
yourself with Lua, don't even bother to try to fully understand these rules.

* An unconventional, but quite convenient feature of Lua is that functions may return multiple results.

So back in 1993 it might have looked 'unconventional' for a function to return multiple results; today i'd
simply say: a function always returns exactly one result; that may be ``null`` (i'd prefer a more specific
choice, lets call it ``NN`` for nomen nominandus), a simple datatype such as a number, or a compound data
type such as a list. It doesn't get any simpler; compare that with the subtleties of Lua:

* Lua always adjusts the number of results from a function to the circumstances of the call.

* When we call a function as a statement, Lua discards all of its results.

* When we use a call as an expression, Lua keeps only the first result.

* We get all results only when the call is the last (or the only) expression in a list of expressions.

* You can force a call to return exactly one result by enclosing it in an extra pair of parentheses.

* In a multiple assignment, a function call as the last (or only) expression produces as many results as
  needed to match the variables.

* When a function call is the last (or the only) argument to another call, all results from the first call
  go as arguments.

* Some functions may receive a variable number of arguments. If we write f(g()) and f has a fixed number of
  arguments, Lua adjusts the number of results of g to the number of parameters of f.

* A constructor also collects all results from a call, without any adjustments. As always, this behavior
  happens only when the call is the last in the list; otherwise, any call produces exactly one result.

* A special function with multiple returns is unpack. It receives an array and returns as results all
  elements from the array.

Amazing stuff, no? Keep clear, don't touch, move on. This set of rules is funny or sad depending on how you
look at it. Observe how utterly superfluous the last rule is, especially in a language where some of the
syntax is controlled by the data type of variables that appear in a given expression. They could have simply
allowed ::

  [ a, b, c, ] = [ 1, 2, 3, ]

but it's hard to climb out of the pit of too complex thinking once you've fallen in. Also observe how this
mishmash of complex stipulations can and will easily conspire to make your code break in new and interesting
ways that will lead to endless hours to debug. Stay simple, Fail early---not valid in this language.

As i said before, these remarks are rather offtopic, and maybe too lengthy, but i still see some value in
relating them. As Confucius said, "When I walk along with two others, they may serve me as my teachers. I
will select their good qualities and follow them, their bad qualities and avoid them.", and as Laozi said,
"Govern a great state as you would fry a small fish, too much and you spoil it". I have met and continue to
meet with large number of programming people who weave incredible levels of complexity into their programs.
Recently i decided to dump a routing library; it is just under a mere hundred lines of JavaScript code, but
next to violating some very essential style rules of JavaScript (never put a brace on the following line, as
it has been demonstrated to break code by Crockford), i find it unpatchable. I mean this thing does one
single rather simple thing, and it does it almost right, but i couldn't get it to do it 100% right. So small
a ball of spaghetti, and you can't untie it. What for? To keep the code secret? It does almost look like
output from a capable code obfuscator.







Data Type Coercion
############################################################################################################

Implicit almost only for numbers, trying to approach the superior quality of Python's time-honed system.

Almost no coercion to or from Booleans: In Python, empty lists, empty dictionaries, empty strings, zero and
``null`` all evaluate as ``false``, but his has become somewhat unnatural to me. I favor explicitness over
cleverness here and regulate that in $LSD, an ``if`` statement must always receive ``true`` or ``false``,
period. No ``null`, no zero allowed. You must always say ``length-of x > 0``, and when a value might be
either a Boolean or ``null``, you must explicitly deal with that situation.





Taints
############################################################################################################



Vows
############################################################################################################

Vows are formal assurances in source code that are similar to those annoying 'have read, understood, and
accepted your terms' clickboxes that pervade the web. Annoying as they might be, they do serve to make
sure that users have (if only technically) consciously opted into a feature, a service, or a clause, which
is important: "Please only ever email me if i have agreed by clicking this box".

If you happen to know Python, you sure are familiar with its '``from __future__ import`` statements'. For
example, older versions of Python did integer division in a different manner than floating-point division,
while current versions treat all cases the same. The old behavior can now be accessed with a special ``//``
(double slash) operator, and for a transitional time, this new behavior was accessible in all source files
that had a statement ``from __future__ import division`` near the top of the file. The good thing about the
``__future__`` facility is its ability to keep a new Python edition compatible with old code, but enable new
features and behaviors in contemporary code. As such, Python is perhaps the first programming language to
provide optional syntactical features. But of course, Python being Python, new versions are released not
very often, and in version 3.2 you get a mere 7 ``__future__`` changes, none of which have to be used,
because the future is now and no major changes are in the pipeline. That is an astounding evolutionary rate
of 0.7 'futures' per year, as roughly a decade elapsed between versions 2.1 and 3.2, and the entire thing
does look as though decommissioned as of this writing.

$LSD is intended to develop linguistic features faster than Python, and to move towards not only flowing
versions (where you basically get a new release whenever anything significant has been implemented), but
also towards 'compositional, optional versions'. This means that the language you use in one file can differ
from the language you use in another file. As a usecase, consider you want to integrate some CoffeeScript
code into your module. CoffeeScript looks very similar to (some versions of) $LSD, so it might be quickest
to do just copy & paste. It's become the somewhat accepted method of authoring doctoral dissertations for
enhanced title-grabbing, so why not. But wait: a CoffeeScript snippet might 'just work' in a typical $LSD
setting, but it may fail silently, as, for example, ``[ a...b ]`` is an *ex*clusive range in CoffeeScript
whereas it is an *in*clusive range in $LSD. Bunked!

In $LSD, vows take on a number of specific syntactical forms; there are not treated as comments but form an
integral part of the code. There are three forms: long, URL, and numerical. All three forms rely on data
collected in the VOWS library. The long form is only used at the module level; the other forms can be used
to mark up both modules and functions, the module statements representing the configuration for module level
code and the default configurations for function level code. In other words, function code inherits the
module configuration and modifies it to suite its requirements.

The astute reader will certainly wonder what happens with the function declaration itself. An example will
make that very clear::

  !!! VOWS/assignments-use-colon-equals
  !!! VOWS/signatures-use-curly-braces

    f :=
      { x, y } ->
        null

Here, we declare a function ``f`` in a purely hypothetical fashion, using ``:=`` for the assignments and
``{}`` for function signatures. A declaration ``!!! XXX/yyy`` causes the function of the name ``XXX/yyy`` to
be called at compile time. Functions that can be meaningfully used in vow declarations are called
'transponders' as  they 'transpose' code, translating it from one (dialect of a) programming language into
(another dialect of a) programming language (a 'transponder' is, originally, a 'transposer-responder',
so saying that it 'transposes' seems correct; incididentally, in fact it does 'respond', too).

The ultimate target of code transposition is, in the context of $LSD, JavaScript, so in theory one could
write a transponder that transposes directly to JavaScript. That is, however, only  an interesting option if
you want to absorb code written in 3rd party languages for which a transponder already exist, as there is
already a very well working tool for a very nice and thought-out language called CoffeeScript, which is a
much more attractive transposition target. And yes, that means that you can mix languages line for line if
you feel you absolutely must and a transponder to JavaScript, CoffeeScript or $LSD exists or you can write
some.

The scope of a declaration is either the rest of the file, if the following statement is not indented, or
the text of the indented block; this is something of a syntactic peculiarity. Vow handlers will initially
get called with the source text of the entire block of their respective scopes (possible leading whitespace
that was present in the first non-empty line after the vow will be removed from each line; notice that in
$LSD, comments have to be properly indented, too); they either produce new source or a data structure that
represents the structure of the program, as far as understood at that point, to be either written out in
CoffeeScript (which is $LSD's transposition target), or to be fed into the next transponder in the row. Each
step will modify the understanding of the code a bit, with the ultimate output being the ursprache of $LSD,
which takes on the a simple and minimalistic forward-Polish-notation syntax with no whistles and no bells.
It is this language that is then in a penultimate step rewritten as CoffeeScript and then translated into
JavaScript.


There are ways $LSD helps you to keep your vows:

* When you run a source file that does not contain any vow, $LSD will stop and ask what to do. It keeps a
  memory when it was called from which user, and will adjust its behavior.

* When the executable is called for the first time, it assumes a novice user and will suggest to stick all
  the standard vows for the current $LSD version literally into the source. The vows can be listed with
  comments that explain each vow.

* Optionally, $LSD can paste all of the existing vows into the file, which amounts to a bare-bones tutorial.

::

  !!! VOW/long-ranges-use-two-dots
  # exclusive, short ranges use ``start..stop`` (2 dots);
  # inclusive, long  ranges use ``min...max`` (3 dots)

  !!! VOW/naked-functions-are-called-not-referenced
  # using naked function names like ``x: f`` will call the function;
  # in order to get a reference, ``f-`` (function name, dash) must be used






Ranges
############################################################################################################

$LSD has range literals that are similar to CoffeeScript, but do have some differences: Most importantly,
``..`` and ``...`` are switched in meaning. This was a hard decision for me to do, as it will beyond doubt
make transition from one to the other of the two languages more error-prone and cause many bugs in original
software written by people with a background in CoffeeScript. On the other hand, there are VOWS, so
hopefully people will accept my choice.

Ranges are constructed using one of two ellipses, ``..`` or ``...``, and require leading and trailing
whitespace when used with the optional fence values; when used without brackets, they produce an iterator::

  1 ..  4      # ≡ -> return ( for x in [ 1, 2, 3, ] )
  1 ... 4      # ≡ -> return ( for x in [ 1, 2, 3, 4, ] )
  ... 4        # ≡ -> return ( for x in [ 0, 1, 2, 3, 4, ] )
  ...          # ≡ -> x = 0; return ( loop yield x; x += 1 )

As the examples show, the convention is that ``a .. b`` with *two* dots stops with ``b - 1``, and ``a ...
b`` with *three* stops with ``b``. This is called the exclusive and the inclusive way of walking over
values, and i believe the mnemonic is easy to keep in mind: when the fences are equal in two range
expression, then the one with the longer row of dots will lead to a longer series of numbers.

Where function parameters are present to implement such a behavior, there are conventionally named
``start`` and ``stop`` for the exclusive and ``min`` and ``max`` for the inclusive case (of course,
``start`` is always identical to ``min``, but it does help improve clarity when they are always used
properly paired).

The implicit start of a range is always zero; its implicit end is ``infinity``. When written inside of
brackets ::

  [ 1 .. 4 ]  # ≡ ( start, stop ) ↔ [ n for n in start .. stop ]

a list will be produced; in this case, omitting the upper boundary or setting it explicitly to infinity will
lead to a syntax error, as the creation of an infinitely long list cannot but fail (this restriction will be
removed from the language as soon as mankind manages to settle on the event horizont of a hyperdimensional
black hole). The generator versions (``...``, ``...infinity``, ``0...`` and ``0...infinity`` and so on) are
not forbidden since they can perform useful work.

More complex ranges are possible, and often necessary::

  for idx in 0 .. length_of names
    apply lower_case to names[ idx ]          # ≡ ( list, idx, f ) ↔ list[ idx ]: f list[ idx ]

Even more choice is possible with putting a function in between two copies of the range operator which are
fenced by parentheses; the fencing is unavoidable to avoid syntactical ambiguity and helps readability.
This construct is called the 'generic range expression'::

  1 ..( ( i ) ↔ i + 2 ).. 8                   # = ↔ for i in [ 3, 5, 7, ]

if the stepping function becomes too complicated (in this example, we demonstrate by becoming more
explicit), it will mess up the readability of the code, so you may want to factor it out::

  increment-by-2: ( i ) ->
    return i + 2

  for n in 1 ..( increment-by-2 ).. 8
    log red "OMG, #{n} is a prime!!!"

The appearances of the ellipses must equal each other, you cannot mix ``..`` and ``...``. The function in
the middle will get called with the value to the left as its sole argument; its return value becomes the
next element in the constructed list. If you haphazardly use a slim-arrow function and forget the ``return``
statement, then ``NN`` is implicitly returned, which will cause an error to be thrown.

One specialty is that you are not confined to integers, or any kind of value, at that: the generalized
range expression fences can be arbitrary values:

  next-chr: ( chr ) ↔ new-chr 1 + cid-of chr
  join 'a' ...( next-chr )... 'z'         # = 'abcdefghijklmnopqrstuvwxyz'

This example starts with letter ``a``, computes its character ID (CID, i.e. the codepoint it got assigned in
Unicode), increments that by one, and returns the character with that CID (which happens to be 'b'). Upon
hitting 'z', the maximum value of the range has been reached, and since it is a long range, that last
element also gets included; it would be left out when used with a short range, which makes this a handy tool
when trying, say, with asynchronous database queries that signal query completion by reaching back ``null``,

The augmented range expression is very powerful, so do be careful with this construct especially when using
it to construct a list; it is very easy to construct runaway conditions::

  ###CAREFUL###

  [ 0 ..( ( i ) ↔ 0 ).. 10 ]                  # identical to ↔ [ 0 for n in 0...infinity ]

It is not difficult to see that this construct will never meet its maximum condition and try to eat up all
available memory, potentially making your computer quite unusable before the process crashes, so you don't
want to run it. Unfortunately, there is very little one can do about that before it actually happens.


Function Definition
############################################################################################################


``->`` or ```` (slim arrow): ordinary function; returns ``NN`` with a blank ``return`` statement or no
explicit ``return`` at all

``<->`` or ``↔`` (giveback arrow): similar to ordinary CS function, the last value of the function execution
is returned even without an explicit return

::

  f: ( P... ) ↔ P/0 * P/1

  f: ( P... ) ↔ P₀ * P₁


























