// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  var $, CND, CS, FLOWMATIC, PS, SourceType, badge, debug, lex, map, ref, rpr;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'FLOWMATIC/LEXER';

  debug = CND.get_logger('debug', badge);

  PS = require('../../pipestreams');

  $ = PS.$, map = PS.map;

  CS = require('coffeescript');

  FLOWMATIC = require('..');

  ref = require('../../coffee-lex'), lex = ref["default"], SourceType = ref.SourceType;

  this.$coffee_lex = function() {
    return $((source, send) => {
      (lex(source)).forEach((token) => {
        var image, start, stop, type;
        type = SourceType[token.type].toLowerCase();
        start = token.start, stop = token.end;
        image = source.slice(start, stop);
        return send({
          start: start,
          stop: stop,
          type: type,
          image: image
        });
      });
      return null;
    });
  };

  this.$add_isid = function() {
    return map((token) => {
      token.isxid = FLOWMATIC.U.is_xidentifier(token.image);
      return token;
    });
  };

  this.$rewrite_whitespace = function() {
    return map((token) => {
      var image, start, stop, type;
      start = token.start, stop = token.stop, type = token.type, image = token.image;
      switch (type) {
        case 'space':
          if (/^\x20+$/.test(image)) {
            token.count = stop - start;
            token.type = 'lws';
          }
          break;
        case 'newline':
          token.count = 1;
          token.type = 'nl';
      }
      return token;
    });
  };

  this.$collapse_newlines = function() {

    /* TAINT does not collapse non-empty blank lines */
    var flush, nl_count, nl_start, send;
    send = null;
    nl_count = 0;
    nl_start = null;
    flush = function() {
      var image, stop;
      if (nl_count > 0) {
        image = '\n'.repeat(nl_count);
        stop = nl_start + nl_count;
        send({
          start: nl_start,
          stop: stop,
          type: 'nl',
          image: image,
          count: nl_count
        });
        nl_count = 0;
        nl_start = null;
      }
      return null;
    };
    return $('null', (token, send_) => {
      var start, type;
      send = send_;
      if (token != null) {
        type = token.type, start = token.start;
        if (type === 'nl') {
          if (nl_start == null) {
            nl_start = start;
          }
          nl_count += 1;
        } else {
          flush();
          send(token);
        }
      } else {
        flush();
      }
      return null;
    });
  };

  this.$add_blank = function() {
    return map((token) => {
      var type;
      type = token.type;
      token.blank = type === 'lws' || type === 'nl' || type === 'space';
      return token;
    });
  };

  this.$add_start_stop = function() {
    var is_first, stop;
    is_first = true;
    stop = 0;
    return $('null', (token, send) => {
      if (is_first) {
        is_first = false;
        send({
          start: 0,
          stop: 0,
          type: 'start',
          blank: true,
          image: ''
        });
      }
      if (token != null) {
        stop = token.stop;
        send(token);
      } else {
        send({
          start: stop,
          stop: stop,
          type: 'stop',
          blank: true,
          image: ''
        });
      }
      return null;
    });
  };

  this.$add_indentation = function() {

    /* TAINT should deal with tab characters, uneven number of spaces */
    return PS.$gliding_window(2, (section) => {
      var t0, t1;
      t0 = section[0], t1 = section[1];
      if (t0.blank && t1.type === 'lws') {
        t1.type = 'indentation';
        t1.level = Math.floor(t1.image.length / 2);
      }
      return null;
    });
  };

  this.$add_indent = function() {
    var prv_level;
    prv_level = 0;
    return PS.$gliding_window(1, (section) => {
      var blank, image, is_indent, isxid, level, my_level, new_token, ref1, start, stop, type;
      ref1 = section[0], start = ref1.start, type = ref1.type, level = ref1.level;
      is_indent = type === 'indentation' && level > prv_level;
      if (is_indent) {
        start = start;
        stop = start;
        blank = false;
        isxid = false;
        while (prv_level < level) {
          prv_level += +1;
          my_level = level + (level - prv_level) - 1;
          image = '';
          type = 'indent';
          new_token = {
            start: start,
            stop: stop,
            type: type,
            image: image,
            level: my_level,
            blank: blank,
            isxid: isxid
          };
          section.unshift(new_token);
        }
      }
      if (level != null) {
        prv_level = level;
      }
      return null;
    });
  };

  this.$add_dedent = function() {
    var prv_level;
    prv_level = 0;
    return PS.$gliding_window(2, (section) => {
      var blank, image, is_dedent, isxid, level, level_0, level_1, my_level, new_token, start, start_0, start_1, stop, t0, t1, type, type_0, type_1;
      t0 = section[0], t1 = section[1];
      start_0 = t0.start, type_0 = t0.type, level_0 = t0.level;
      start_1 = t1.start, type_1 = t1.type, level_1 = t1.level;
      level = null;
      if (type_0 === 'nl') {
        if (type_1 === 'indentation') {
          level = level_1;
        } else {
          level = 0;
        }
      }
      is_dedent = (level != null) && (level < prv_level) && (type_1 !== 'indent');
      if (is_dedent) {
        start = start_0;
        stop = start;
        blank = false;
        isxid = false;
        while (prv_level > level) {
          prv_level += -1;
          my_level = level + (level - prv_level) + 1;
          image = '';
          type = 'dedent';
          new_token = {
            start: start,
            stop: stop,
            type: type,
            image: image,
            level: my_level,
            blank: blank,
            isxid: isxid
          };
          section.unshift(new_token);
        }
      }
      prv_level = level != null ? level : (level_1 != null ? level_1 : prv_level);
      return null;
    });
  };

  this.$add_eofdedent = function() {
    var prv_level;
    prv_level = 0;
    return PS.$gliding_window(2, (section) => {
      var blank, image, is_eofdedent, isxid, level, level_0, level_1, new_token, start, start_0, start_1, stop, t0, t1, type, type_0, type_1;
      t0 = section[0], t1 = section[1];
      start_0 = t0.start, type_0 = t0.type, level_0 = t0.level;
      start_1 = t1.start, type_1 = t1.type, level_1 = t1.level;
      is_eofdedent = type_1 === 'stop' && prv_level > 0;
      if (is_eofdedent) {
        start = start_1;
        stop = start;
        blank = false;
        isxid = false;
        level = level_1;
        image = '';
        type = 'dedent';
        level = prv_level;
        section.pop();
        while (level > 0) {
          level += -1;
          new_token = {
            start: start,
            stop: stop,
            type: type,
            image: image,
            level: level,
            blank: blank,
            isxid: isxid
          };
          section.push(new_token);
        }
        section.push(t1);
      }
      if (level_1 != null) {
        prv_level = level_1;
      }
      return null;
    });
  };

  this.$lex = function() {
    var pipeline;
    pipeline = [];
    pipeline.push(this.$coffee_lex());
    pipeline.push(this.$add_isid());
    pipeline.push(this.$rewrite_whitespace());
    pipeline.push(this.$collapse_newlines());
    pipeline.push(this.$add_blank());
    pipeline.push(this.$add_start_stop());
    pipeline.push(this.$add_indentation());
    pipeline.push(this.$add_indent());
    pipeline.push(this.$add_dedent());
    pipeline.push(this.$add_eofdedent());
    return PS.pull(...pipeline);
  };

}).call(this);

//# sourceMappingURL=lexer.js.map
