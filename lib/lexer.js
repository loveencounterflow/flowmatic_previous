// Generated by CoffeeScript 2.0.0-beta2
(function() {
  var $, CND, CS, FLOWMATIC, PS, SourceType, badge, debug, lex, map, rpr;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'FLOWMATIC/LEXER';

  debug = CND.get_logger('debug', badge);

  PS = require('pipestreams');

  ({$, map} = PS);

  CS = require('coffeescript');

  FLOWMATIC = require('..');

  ({
    default: lex,
    SourceType
  } = require('stupid-coffee-lexer'));

  this.$coffee_lex = function() {
    return $((source, send) => {
      (lex(source)).forEach((token) => {
        var image, start, stop, type;
        type = SourceType[token.type].toLowerCase();
        ({
          start,
          end: stop
        } = token);
        image = source.slice(start, stop);
        return send({start, stop, type, image});
      });
      return null;
    });
  };

  this.$add_isid = function() {
    return map((token) => {
      token.isxid = FLOWMATIC.U.is_xidentifier(token.image);
      return token;
    });
  };

  this.$rewrite_whitespace = function() {
    return map((token) => {
      var image, start, stop, type;
      ({start, stop, type, image} = token);
      switch (type) {
        case 'space':
          if (/^\x20+$/.test(image)) {
            token.count = stop - start;
            token.type = 'lws';
          }
          break;
        case 'newline':
          token.count = 1;
          token.type = 'nl';
      }
      return token;
    });
  };

  this.$collapse_newlines = function() {

    /* TAINT does not collapse non-empty blank lines */
    var flush, nl_count, nl_start, send;
    send = null;
    nl_count = 0;
    nl_start = null;
    flush = function() {
      var image, stop;
      if (nl_count > 0) {
        image = '\n'.repeat(nl_count);
        stop = nl_start + nl_count;
        send({
          start: nl_start,
          stop,
          type: 'nl',
          image,
          count: nl_count
        });
        nl_count = 0;
        nl_start = null;
      }
      return null;
    };
    return $('null', (token, send_) => {
      var start, type;
      send = send_;
      if (token != null) {
        ({type, start} = token);
        if (type === 'nl') {
          if (nl_start == null) {
            nl_start = start;
          }
          nl_count += 1;
        } else {
          flush();
          send(token);
        }
      } else {
        flush();
      }
      return null;
    });
  };

  this.$add_blank = function() {
    return map((token) => {
      var type;
      ({type} = token);
      token.blank = type === 'lws' || type === 'nl' || type === 'space';
      return token;
    });
  };

  this.$add_start_stop = function() {
    var is_first, stop;
    is_first = true;
    stop = 0;
    return $('null', (token, send) => {
      if (is_first) {
        is_first = false;
        send({
          start: 0,
          stop: 0,
          type: 'start',
          blank: true,
          image: ''
        });
      }
      if (token != null) {
        ({stop} = token);
        send(token);
      } else {
        send({
          start: stop,
          stop,
          type: 'stop',
          blank: true,
          image: ''
        });
      }
      return null;
    });
  };

  this.$add_indentation = function() {

    /* TAINT should deal with tab characters, uneven number of spaces */
    return PS.$gliding_window(2, (section) => {
      var t0, t1;
      [t0, t1] = section;
      if (t0.blank && t1.type === 'lws') {
        t1.type = 'indentation';
        t1.level = Math.floor(t1.image.length / 2);
      }
      return null;
    });
  };

  this.$add_indent = function() {
    var prv_level;
    prv_level = 0;
    return PS.$gliding_window(1, (section) => {
      var blank, image, is_indent, isxid, level, my_level, new_token, start, stop, type;
      [{start, type, level}] = section;
      is_indent = type === 'indentation' && level > prv_level;
      if (is_indent) {
        start = start;
        stop = start;
        blank = false;
        isxid = false;
        while (prv_level < level) {
          prv_level += +1;
          my_level = level + (level - prv_level) - 1;
          image = '';
          type = 'indent';
          new_token = {
            start,
            stop,
            type,
            image,
            level: my_level,
            blank,
            isxid
          };
          section.unshift(new_token);
        }
      }
      if (level != null) {
        prv_level = level;
      }
      return null;
    });
  };

  this.$add_dedent = function() {
    var prv_level;
    prv_level = 0;
    return PS.$gliding_window(2, (section) => {
      var blank, image, is_dedent, isxid, level, level_0, level_1, my_level, new_token, start, start_0, start_1, stop, t0, t1, type, type_0, type_1;
      [t0, t1] = section;
      ({
        start: start_0,
        type: type_0,
        level: level_0
      } = t0);
      ({
        start: start_1,
        type: type_1,
        level: level_1
      } = t1);
      level = null;
      if (type_0 === 'nl') {
        if (type_1 === 'indentation') {
          level = level_1;
        } else {
          level = 0;
        }
      }
      is_dedent = (level != null) && (level < prv_level) && (type_1 !== 'indent');
      if (is_dedent) {
        start = start_0;
        stop = start;
        blank = false;
        isxid = false;
        while (prv_level > level) {
          prv_level += -1;
          my_level = level + (level - prv_level) + 1;
          image = '';
          type = 'dedent';
          new_token = {
            start,
            stop,
            type,
            image,
            level: my_level,
            blank,
            isxid
          };
          section.unshift(new_token);
        }
      }
      prv_level = level != null ? level : (level_1 != null ? level_1 : prv_level);
      return null;
    });
  };

  this.$add_eofdedent = function() {
    var prv_level;
    prv_level = 0;
    return PS.$gliding_window(2, (section) => {
      var blank, image, is_eofdedent, isxid, level, level_0, level_1, new_token, start, start_0, start_1, stop, t0, t1, type, type_0, type_1;
      [t0, t1] = section;
      ({
        start: start_0,
        type: type_0,
        level: level_0
      } = t0);
      ({
        start: start_1,
        type: type_1,
        level: level_1
      } = t1);
      is_eofdedent = type_1 === 'stop' && prv_level > 0;
      if (is_eofdedent) {
        start = start_1;
        stop = start;
        blank = false;
        isxid = false;
        level = level_1;
        image = '';
        type = 'dedent';
        level = prv_level;
        section.pop();
        while (level > 0) {
          level += -1;
          new_token = {start, stop, type, image, level, blank, isxid};
          section.push(new_token);
        }
        section.push(t1);
      }
      if (level_1 != null) {
        prv_level = level_1;
      }
      return null;
    });
  };

  this.$lex = function() {
    var pipeline;
    pipeline = [];
    pipeline.push(this.$coffee_lex());
    pipeline.push(this.$add_isid());
    pipeline.push(this.$rewrite_whitespace());
    pipeline.push(this.$collapse_newlines());
    pipeline.push(this.$add_blank());
    pipeline.push(this.$add_start_stop());
    pipeline.push(this.$add_indentation());
    pipeline.push(this.$add_indent());
    pipeline.push(this.$add_dedent());
    pipeline.push(this.$add_eofdedent());
    return PS.pull(...pipeline);
  };

}).call(this);

//# sourceMappingURL=lexer.js.map
