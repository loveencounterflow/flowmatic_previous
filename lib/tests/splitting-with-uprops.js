// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  'use strict';

  /*
  * https://github.com/devongovett/unicode-trie
  * https://github.com/devongovett/unicode-properties
  
    When implementing many Unicode algorithms such as text segmentation, normalization, bidi processing, etc.,
    fast access to character metadata is crucial to good performance. There over a million code points in the
    Unicode standard, many of which produce the same result when looked up, so an array or hash table is not
    appropriate - those data structures are fast but would require a lot of memory. The data is generally
    grouped in ranges, so you could do a binary search, but that is not fast enough for some applications.
  
    The International Components for Unicode (ICU) project came up with a data structure based on a Trie that
    provides fast access to Unicode metadata. The range data is precompiled to a serialized and flattened
    trie, which is then used at runtime to lookup the necessary data. According to my own tests, this is
    generally at least 50% faster than binary search, with not too much additional memory required.
  
  
  * https://github.com/mathiasbynens/regenerate-unicode-properties
  
  
  for reference:
  * (https://github.com/mathiasbynens/regenerate)
  * (https://github.com/mathiasbynens/unicode-8.0.0)
  * (https://github.com/mathiasbynens/node-unicode-data)
  * ncr
   */
  var $, CND, FM, PATH, PS, TAP, UPROPS, badge, brown, chrrpr, color, crimson, debug, echo, f, flag, get_color, help, indigo, info, join, lime, map, olive, orange, pink, pluck, plum, rainbow, rpr, sepia, shorten, steel, step, thin_out, toggle, ucc_of, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'FLOWMATIC/TESTS/BASIC';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  UPROPS = require('unicode-properties');

  TAP = require('tap');

  sepia = CND.sepia, plum = CND.plum, pink = CND.pink, orange = CND.orange, olive = CND.olive, indigo = CND.indigo, crimson = CND.crimson, brown = CND.brown, lime = CND.lime, steel = CND.steel;

  ucc_of = function(chr) {
    return (UPROPS.getCategory(chr.codePointAt(0)))[0];
  };

  thin_out = function(list) {
    var i, len, results, x;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      x = list[i];
      if (x !== '') {
        results.push(x);
      }
    }
    return results;
  };

  shorten = function(text) {
    if (text.length < 2) {
      return text;
    } else {
      return text.slice(1, text.length - 1);
    }
  };

  chrrpr = function(text) {
    if (/^\s+$/.test(text)) {
      return CND.reverse(shorten(rpr(text)));
    } else {
      return text;
    }
  };

  flag = true;

  toggle = function() {
    return flag = !flag;
  };

  get_color = function(c1, c2) {
    return function(x) {
      if (toggle()) {
        return c1(x);
      } else {
        return c2(x);
      }
    };
  };

  color = get_color(steel, orange);

  rainbow = function(list) {
    var x;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        x = list[i];
        results.push(color(chrrpr(x)));
      }
      return results;
    })()).join('');
  };

  join = function(list) {
    return list.join('_');
  };


  /* TAINT pluck for lists looks different */

  pluck = function(x, key) {
    var R;
    R = x[key];
    delete x[key];
    return R;
  };

  PS = require('pipestreams');

  $ = PS.$, map = PS.map;

  step = require('coffeenode-suspend').step;

  f = function() {
    this.$prepare = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$prepare.$as_lines());
      pipeline.push(this.$prepare.$as_line_events());
      pipeline.push(this.$prepare.$add_positions());
      pipeline.push(this.$prepare.$add_chunks());
      pipeline.push(this.$prepare.$TEST_recognize_ncrs());
      pipeline.push(this.$prepare.$as_chrs());
      return PS.pull(...pipeline);
    };
    this.$prepare.$as_lines = () => {

      /* Only recognizes `\n` (as it should). In the sequences `\r`, `\r\n`, `\n\r`, `\u2028`, `\u2029`, only
      `\n` (U+000a) causes a new line, and all other codepoints are preserved.
       */
      return PS.$split();
    };
    this.$prepare.$as_line_events = () => {

      /* TAINT assuming all lines are terminated with `\n` */
      return PS.map(function(image) {
        return {
          type: 'line',
          image: image
        };
      });
    };
    this.$prepare.$add_positions = () => {
      var line_nr, start, stop;
      line_nr = 0;
      start = 0;
      stop = 0;
      return PS.map(function(event) {
        var image;
        image = event.image;
        line_nr += +1;

        /* `+ 1` to account for newline that has been omitted */
        stop = start + image.length + 1;
        event.position = {
          line: line_nr,
          start: start,
          stop: stop
        };
        start = stop;
        return event;
      });
    };
    this.$prepare.$add_chunks = () => {

      /* TAINT assuming all lines are terminated with `\n` */
      return PS.map(function(event) {
        var chunk, position;
        if (event.type !== 'line') {
          return event;
        }
        position = Object.assign({}, event.position);

        /* TAINT *must* be able at this point to distinguish lines with and without newline */
        chunk = Object.assign({}, event, {
          position: position
        });
        chunk.type = 'chrs';
        event.chunks = [chunk];
        debug('7739', chunk.position === event.position);
        return event;
      });
    };
    this.$prepare.$TEST_recognize_ncrs = function() {
      var pattern;
      pattern = /(&\#x[0-9a-f]{1,6};)/g;
      return PS.map(function(event) {
        var i, image, len, source_chunk, source_chunks, target_chunks;
        if (event.type !== 'line') {
          return event;
        }
        debug('32221', event);
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        for (i = 0, len = source_chunks.length; i < len; i++) {
          source_chunk = source_chunks[i];
          if (source_chunk.type !== 'chrs') {
            target_chunks.push(source_chunk);
            continue;
          }
          image = source_chunk.image;
          debug(image.split(pattern));
        }
        info('99982', event);
        return event;
      });
    };
    this.$prepare.$as_chrs = () => {
      return PS.map(function(event) {
        var chr, i, j, len, len1, line_nr, position, ref, ref1, source_chunk, source_chunks, start, stop, target_chunk, target_chunks;
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        for (i = 0, len = source_chunks.length; i < len; i++) {
          source_chunk = source_chunks[i];
          if (source_chunk.type !== 'chrs') {
            target_chunks.push(source_chunk);
            continue;
          }
          ref = source_chunk.position, line_nr = ref.line, start = ref.start;
          ref1 = Array.from(source_chunk.image);
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            chr = ref1[j];
            stop = start + chr.length;
            position = {
              line: line_nr,
              start: start,
              stop: stop
            };
            target_chunk = {
              type: 'chr',
              position: position,
              image: chr
            };
            start = stop;
            target_chunks.push(target_chunk);
          }
        }
        return event;
      });
    };
    this.$group_chrs_by_ucc = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$group_chrs_by_ucc.$add_uccs());
      pipeline.push(this.$group_chrs_by_ucc.$rewrite_lws());
      pipeline.push(this.$group_chrs_by_ucc.$group_by_ucc());
      return PS.pull(...pipeline);
    };
    this.$group_chrs_by_ucc.$add_uccs = () => {
      return PS.map(function(event) {
        var chunk, i, len, ref;
        if (event.type !== 'line') {
          return event;
        }
        ref = event.chunks;
        for (i = 0, len = ref.length; i < len; i++) {
          chunk = ref[i];
          if (chunk.type !== 'chr') {
            continue;
          }
          chunk.ucc = ucc_of(chunk.image);
        }
        return event;
      });
    };
    this.$group_chrs_by_ucc.$rewrite_lws = function() {
      return PS.map(function(event) {
        var chunk, i, len, ref;
        if (event.type !== 'line') {
          return event;
        }
        ref = event.chunks;
        for (i = 0, len = ref.length; i < len; i++) {
          chunk = ref[i];
          if (chunk.type !== 'chr') {
            continue;
          }
          if (chunk.image !== '\u0020') {
            continue;
          }
          chunk.ucc = 'lws';
        }
        return event;
      });
    };
    this.$group_chrs_by_ucc.$group_by_ucc = function() {

      /* TAINT could / should be optimized to use collector list, then concatenate all chunks at once */
      var merge_chunks;
      merge_chunks = function(a, b) {
        var R;
        R = Object.assign({}, a);
        R.position = Object.assign({}, R.position);
        R.type = 'chrs';
        if (b == null) {
          return R;
        }
        if (a.position.line !== b.position.line) {
          throw new Error(`can't merge chunks from different lines: ${rpr(a)}, ${rpr(b)}`);
        }
        if (!(a.position.start <= b.position.start)) {
          throw new Error("MEH #1");
        }
        if (a.position.stop !== b.position.start) {
          throw new Error("MEH #2");
        }
        if (a.ucc !== b.ucc) {
          throw new Error("MEH #3");
        }
        R.position.stop = b.position.stop;
        R.image = R.image + b.image;
        return R;
      };
      return PS.map(function(event) {
        var chunk, i, len, prv_ucc, source_chunks, target_chunk, target_chunks, ucc;
        if (event.type !== 'line') {
          return event;
        }
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        target_chunk = null;
        for (i = 0, len = source_chunks.length; i < len; i++) {
          chunk = source_chunks[i];
          if (chunk.type !== 'chr') {
            target_chunks.push(chunk);
            continue;
          }
          ucc = chunk.ucc;
          if (ucc === prv_ucc) {
            target_chunk = merge_chunks(target_chunk, chunk);
          } else {
            if (target_chunk != null) {
              target_chunks.push(target_chunk);
              target_chunk = null;
            }
          }
          if (target_chunk == null) {
            target_chunk = merge_chunks(chunk);
          }
          prv_ucc = ucc;
        }
        if (target_chunk != null) {
          target_chunks.push(target_chunk);
        }
        return event;
      });
    };
    this.$lex = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$prepare());
      pipeline.push(this.$group_chrs_by_ucc());
      return PS.pull(...pipeline);
    };
    return this.lex = function(text, handler) {
      var Z, pipeline;
      pipeline = [];
      Z = [];
      pipeline.push(PS.new_text_source(text));
      pipeline.push(this.$lex());
      pipeline.push($('null', function(event, send) {
        if (event != null) {
          Z.push(event);
          send(event);
        } else {
          handler(null, Z);
        }
        return null;
      }));
      pipeline.push(PS.$drain());
      return PS.pull(...pipeline);
    };
  };

  FM = {};

  f.apply(FM.LEXER = {});

  TAP.test("basic model", function(T) {
    var probes_and_matchers, self;
    debug('-----------------------------------------------');
    debug("basic model");
    debug('-----------------------------------------------');
    probes_and_matchers = [['a&#x21;z', '']];
    thin_out = function(list) {
      var i, len, results, x;
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        x = list[i];
        if (x !== '') {
          results.push(x);
        }
      }
      return results;
    };
    join = function(list) {
      return list.join('_');
    };
    self = this;
    step(function*(resume) {
      var chunk, i, j, k, len, len1, len2, line, lines, matcher, probe, ref, ref1;
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
        urge(rpr(probe));
        lines = (yield FM.LEXER.lex(probe, resume));
        for (j = 0, len1 = lines.length; j < len1; j++) {
          line = lines[j];
          whisper(JSON.stringify(line));
          warn(line.position, rpr(line.image));
          ref1 = line.chunks;
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            chunk = ref1[k];
            help('  ' + JSON.stringify(chunk));
          }
        }
      }
      T.end();
      return null;
    });
    return null;
  });

}).call(this);

//# sourceMappingURL=splitting-with-uprops.js.map
