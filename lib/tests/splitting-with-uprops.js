// Generated by CoffeeScript 2.0.0-beta2
(function() {
  'use strict';

  /*
  * https://github.com/devongovett/unicode-trie
  * https://github.com/devongovett/unicode-properties
  
    When implementing many Unicode algorithms such as text segmentation, normalization, bidi processing, etc.,
    fast access to character metadata is crucial to good performance. There are over a million code points in the
    Unicode standard, many of which produce the same result when looked up, so an array or hash table is not
    appropriate - those data structures are fast but would require a lot of memory. The data is generally
    grouped in ranges, so you could do a binary search, but that is not fast enough for some applications.
  
    The International Components for Unicode (ICU) project came up with a data structure based on a Trie that
    provides fast access to Unicode metadata. The range data is precompiled to a serialized and flattened
    trie, which is then used at runtime to lookup the necessary data. According to my own tests, this is
    generally at least 50% faster than binary search, with not too much additional memory required.
  
  
  * https://github.com/mathiasbynens/regenerate-unicode-properties
  
  
  for reference:
  * (https://github.com/mathiasbynens/regenerate)
  * (https://github.com/mathiasbynens/unicode-8.0.0)
  * (https://github.com/mathiasbynens/node-unicode-data)
  * ncr
   */
  var $, CND, FM, PATH, PS, TAP, UPROPS, badge, brown, chrrpr, color, crimson, debug, echo, f, flag, g, get_color, help, indigo, info, join, lime, map, olive, orange, pink, pluck, plum, rainbow, rpr, sepia, shorten, steel, step, thin_out, toggle, ucc_of, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'FLOWMATIC/TESTS/BASIC';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  PATH = require('path');

  UPROPS = require('unicode-properties');

  TAP = require('tap');

  ({sepia, plum, pink, orange, olive, indigo, crimson, brown, lime, steel} = CND);

  ucc_of = function(chr) {
    var ucc;
    ucc = UPROPS.getCategory(chr.codePointAt(0));
    return ucc[0];
  };

  thin_out = function(list) {
    var i, len, results, x;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      x = list[i];
      if (x !== '') {
        results.push(x);
      }
    }
    return results;
  };

  shorten = function(text) {
    if (text.length < 2) {
      return text;
    } else {
      return text.slice(1, text.length - 1);
    }
  };

  chrrpr = function(text) {
    if (/^\s+$/.test(text)) {
      return CND.reverse(shorten(rpr(text)));
    } else {
      return text;
    }
  };

  flag = true;

  toggle = function() {
    return flag = !flag;
  };

  get_color = function(c1, c2) {
    return function(x) {
      if (toggle()) {
        return c1(x);
      } else {
        return c2(x);
      }
    };
  };

  color = get_color(steel, orange);

  rainbow = function(list) {
    var x;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        x = list[i];
        results.push(color(chrrpr(x)));
      }
      return results;
    })()).join('');
  };

  join = function(list) {
    return list.join('_');
  };


  /* TAINT pluck for lists looks different */

  pluck = function(x, key) {
    var R;
    R = x[key];
    delete x[key];
    return R;
  };

  PS = require('pipestreams');

  ({$, map} = PS);

  ({step} = require('coffeenode-suspend'));

  FM = {};

  f = function() {
    this.$prepare = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$prepare.$as_lines());
      pipeline.push(this.$prepare.$as_line_events());
      pipeline.push(this.$prepare.$add_positions());
      pipeline.push(this.$prepare.$add_chunks());
      pipeline.push(this.$prepare.$recognize_fncrs());
      pipeline.push(this.$prepare.$recognize_ncrs());
      pipeline.push(this.$prepare.$splice_ncrs());
      pipeline.push(this.$prepare.$as_chrs());
      return PS.pull(...pipeline);
    };
    this.$prepare.$as_lines = () => {

      /* Only recognizes `\n` (as it should). In the sequences `\r`, `\r\n`, `\n\r`, `\u2028`, `\u2029`, only
      `\n` (U+000a) causes a new line, and all other codepoints are preserved.
       */
      return PS.$split();
    };
    this.$prepare.$as_line_events = () => {

      /* TAINT assuming all lines are terminated with `\n` */
      return PS.map((image) => {

        /* TAINT technically, not a chunk (?) */
        return FM.U.new_chunk({
          type: 'line',
          image
        });
      });
    };
    this.$prepare.$add_positions = () => {
      var x, xx, y;
      y = -1;
      x = 0;
      xx = 0;
      return PS.map(function(event) {
        var image;
        ({image} = event);
        y += +1;

        /* `+ 1` to account for newline that has been omitted */
        xx = x + image.length + 1;
        event.y = y;
        event.x = x;
        event.xx = xx;
        x = xx;
        return event;
      });
    };
    this.$prepare.$add_chunks = () => {

      /* TAINT assuming all lines are terminated with `\n` */
      return PS.map(function(event) {
        var chunk;
        if (event.type !== 'line') {
          return event;
        }

        /* TAINT *must* be able at this point to distinguish lines with and without newline */
        chunk = FM.U.new_chunk(event);
        chunk.type = 'chrs';
        event.chunks = [chunk];
        return event;
      });
    };
    this.$prepare.$recognize_fncrs = function() {
      var pattern;
      pattern = /([-0-9a-z]+[\/-][0-9a-f]+)/g;
      return PS.map(function(event) {
        var i, image, is_plain, j, len, len1, part, ref, source_chunk, source_chunks, target_chunks, x, xx, y;
        if (event.type !== 'line') {
          return event;
        }
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        for (i = 0, len = source_chunks.length; i < len; i++) {
          source_chunk = source_chunks[i];
          if (source_chunk.type !== 'chrs') {
            target_chunks.push(source_chunk);
            continue;
          }
          ({image, y, x} = source_chunk);
          is_plain = false;
          xx = x;
          ref = image.split(pattern);
          for (j = 0, len1 = ref.length; j < len1; j++) {
            part = ref[j];
            is_plain = !is_plain;
            xx += part.length;
            if (is_plain) {
              target_chunks.push(FM.U.new_chunk({
                type: 'chrs',
                y,
                x,
                xx,
                image: part
              }));
              x = xx;
              continue;
            }
            target_chunks.push(FM.U.new_chunk({
              type: 'fncr',
              y,
              x,
              xx,
              image: part
            }));
            x = xx;
          }
        }
        return event;
      });
    };
    this.$prepare.$recognize_ncrs = function() {
      var pattern;
      pattern = /(&\#x[0-9a-f]{1,6};)/g;
      return PS.map(function(event) {
        var cid, i, image, is_plain, j, len, len1, part, ref, source_chunk, source_chunks, target, target_chunks, x, xx, y;
        if (event.type !== 'line') {
          return event;
        }
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        for (i = 0, len = source_chunks.length; i < len; i++) {
          source_chunk = source_chunks[i];
          if (source_chunk.type !== 'chrs') {
            target_chunks.push(source_chunk);
            continue;
          }
          ({image, y, x} = source_chunk);
          is_plain = false;
          xx = x;
          ref = image.split(pattern);
          for (j = 0, len1 = ref.length; j < len1; j++) {
            part = ref[j];
            is_plain = !is_plain;
            xx += part.length;
            if (is_plain) {
              target_chunks.push(FM.U.new_chunk({
                type: 'chrs',
                y,
                x,
                xx,
                image: part
              }));
              x = xx;
              continue;
            }
            cid = parseInt(part.slice(3, part.length - 1), 16);
            target = String.fromCodePoint(cid);
            target_chunks.push(FM.U.new_chunk({
              type: 'ncr',
              y,
              x,
              xx,
              image: part,
              cid,
              target
            }));
            x = xx;
          }
        }
        return event;
      });
    };
    this.$prepare.$splice_ncrs = function() {
      return PS.map(function(event) {
        var chunk, i, idx, len, ref;
        if (event.type !== 'line') {
          return event;
        }
        ref = event.chunks;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          chunk = ref[idx];
          if (chunk.type !== 'ncr') {
            continue;
          }
          event.chunks[idx] = chunk = FM.U.new_chunk(chunk);
          delete chunk.cid;
          chunk.type = 'chr';
        }
        return event;
      });
    };
    this.$prepare.$as_chrs = () => {
      return PS.map(function(event) {
        var chr, i, j, len, len1, ref, source_chunk, source_chunks, target_chunk, target_chunks, x, xx, y;
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        for (i = 0, len = source_chunks.length; i < len; i++) {
          source_chunk = source_chunks[i];
          if (source_chunk.type !== 'chrs') {
            target_chunks.push(source_chunk);
            continue;
          }
          ({y, x} = source_chunk);
          ref = Array.from(source_chunk.image);
          for (j = 0, len1 = ref.length; j < len1; j++) {
            chr = ref[j];
            xx = x + chr.length;
            target_chunk = FM.U.new_chunk({
              type: 'chr',
              y,
              x,
              xx,
              image: chr
            });
            x = xx;
            target_chunks.push(target_chunk);
          }
        }
        return event;
      });
    };
    this.$group_chrs_by_ucc = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$group_chrs_by_ucc.$add_uccs());
      pipeline.push(this.$group_chrs_by_ucc.$rewrite_lws());
      pipeline.push(this.$group_chrs_by_ucc.$group_by_ucc());
      return PS.pull(...pipeline);
    };
    this.$group_chrs_by_ucc.$add_uccs = () => {
      return PS.map(function(event) {
        var chunk, i, len, ref;
        if (event.type !== 'line') {
          return event;
        }
        ref = event.chunks;
        for (i = 0, len = ref.length; i < len; i++) {
          chunk = ref[i];
          if (chunk.type !== 'chr') {
            continue;
          }
          chunk.ucc = ucc_of(chunk.target);
        }
        return event;
      });
    };
    this.$group_chrs_by_ucc.$rewrite_lws = function() {
      return PS.map(function(event) {
        var chunk, i, idx, len, ref;
        if (event.type !== 'line') {
          return event;
        }
        ref = event.chunks;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          chunk = ref[idx];
          if (chunk.type !== 'chr') {
            continue;
          }
          if (chunk.target !== '\u0020') {
            continue;
          }
          event.chunks[idx] = chunk = FM.U.new_chunk(chunk, {
            ucc: 'lws'
          });
        }
        return event;
      });
    };
    this.$group_chrs_by_ucc.$group_by_ucc = function() {

      /* TAINT could / should be optimized to use collector list, then concatenate all chunks at once */
      return PS.map(function(event) {
        var chunk, flush, i, len, prv_ucc, source_chunks, target_chunk, target_chunks, ucc;
        if (event.type !== 'line') {
          return event;
        }
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        target_chunk = null;
        prv_ucc = null;
        flush = function() {
          if (target_chunk != null) {
            target_chunks.push(target_chunk);
          }
          target_chunk = null;
          return prv_ucc = null;
        };
        for (i = 0, len = source_chunks.length; i < len; i++) {
          chunk = source_chunks[i];
          if (chunk.type !== 'chr') {
            flush();
            target_chunks.push(chunk);
            continue;
          }
          ({ucc} = chunk);
          if (ucc === prv_ucc) {
            target_chunk = FM.U.merge_chunks(target_chunk, chunk, {
              type: 'chrs'
            });
          } else {
            flush();
          }
          if (target_chunk == null) {
            target_chunk = FM.U.merge_chunks(chunk, null, {
              type: 'chrs'
            });
          }
          prv_ucc = ucc;
        }
        flush();
        return event;
      });
    };
    this.$identifiers = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$identifiers.$add_identifier_type());
      pipeline.push(this.$identifiers.$group_identifiers());
      return PS.pull(...pipeline);
    };
    this.$identifiers.$add_identifier_type = () => {
      return PS.map((event) => {
        var chunk, i, idx, len, ref;
        if (event.type !== 'line') {
          return event;
        }
        ref = event.chunks;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          chunk = ref[idx];
          if (!((chunk.type === 'chrs') && (chunk.ucc === 'L'))) {
            continue;
          }
          chunk.type = 'identifier';
        }
        return event;
      });
    };
    this.$identifiers.$group_identifiers = () => {
      return PS.map((event) => {
        var chunk, i, idx, len, prv_type, source_chunks, target_chunk, target_chunks;
        if (event.type !== 'line') {
          return event;
        }
        prv_type = null;
        target_chunk = null;
        source_chunks = event.chunks;
        target_chunks = event.chunks = [];
        for (idx = i = 0, len = source_chunks.length; i < len; idx = ++i) {
          chunk = source_chunks[idx];
          if (chunk.type === 'identifier') {
            if (target_chunk == null) {
              target_chunk = FM.U.merge_chunks(chunk);
              prv_type = chunk.type;
              delete target_chunk.ucc;
              continue;
            }
            target_chunk = FM.U.merge_chunks(target_chunk, chunk);
            continue;
          }
          if (prv_type === 'identifier') {
            if ((chunk.image === '-') || (chunk.image === '_') || (chunk.ucc === 'N')) {
              target_chunk = FM.U.merge_chunks(target_chunk, chunk);
              continue;
            }
          }
          if (target_chunk != null) {
            target_chunks.push(target_chunk);
          }
          target_chunks.push(chunk);
          target_chunk = null;
          prv_type = chunk.type;
        }
        if (target_chunk != null) {
          target_chunks.push(target_chunk);
        }
        return event;
      });
    };
    this.$finalize = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$finalize.$update_line_target());
      return PS.pull(...pipeline);
    };
    this.$finalize.$update_line_target = () => {
      return PS.map((event) => {
        var chunk;
        if (event.type !== 'line') {
          return event;
        }
        event.target = ((function() {
          var i, len, ref, results;
          ref = event.chunks;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            chunk = ref[i];
            results.push(chunk.target);
          }
          return results;
        })()).join('');
        return event;
      });
    };
    this.$lex = function() {
      var pipeline;
      pipeline = [];
      pipeline.push(this.$prepare());
      pipeline.push(this.$group_chrs_by_ucc());
      pipeline.push(this.$identifiers());
      pipeline.push(this.$finalize());
      return PS.pull(...pipeline);
    };
    return this.lex = function(text, handler) {
      var Z, pipeline;
      pipeline = [];
      Z = [];
      pipeline.push(PS.new_text_source(text));
      pipeline.push(this.$lex());
      pipeline.push($('null', function(event, send) {
        if (event != null) {
          Z.push(event);
          send(event);
        } else {
          handler(null, Z);
        }
        return null;
      }));
      pipeline.push(PS.$drain());
      return PS.pull(...pipeline);
    };
  };

  g = function() {
    this.new_chunk = function(...P) {
      var R;
      R = Object.assign({}, ...P);
      if (R.target == null) {
        R.target = R.image;
      }
      return R;
    };
    return this.merge_chunks = function(a, b, ...P) {
      var R;
      R = FM.U.new_chunk(a, ...P);
      if (b == null) {
        return R;
      }
      if (a.y !== b.y) {
        throw new Error(`can't merge chunks from different lines: ${rpr(a)}, ${rpr(b)}`);
      }
      if (!(a.x <= b.x)) {
        throw new Error("MEH #1");
      }
      if (a.xx !== b.x) {
        throw new Error("MEH #2");
      }
      R.xx = b.xx;
      R.image = R.image + b.image;
      R.target = R.target + b.target;
      return R;
    };
  };

  FM = {};

  f.apply(FM.LEXER = {});

  g.apply(FM.U = {});

  TAP.test("basic model", function(T) {
    var probes_and_matchers, self;
    debug('-----------------------------------------------');
    debug("basic model");
    debug('-----------------------------------------------');
    probes_and_matchers = [['y = x ** 2 for x in [ 1, 2, 3, ]', ''], ['123abc$%\n2\n3\n456 xyz\n\n', ''], ['a&#x64;z', ''], ['a&#x21;z', ''], ['a&#x21;bc&#x22;de', ''], ['u-cjk-xb/22f33 &#x22f33; ⿰匡夊', ''], ['my-sum = ( foo-knows + bar42 ) * under_score', '']];
    thin_out = function(list) {
      var i, len, results, x;
      results = [];
      for (i = 0, len = list.length; i < len; i++) {
        x = list[i];
        if (x !== '') {
          results.push(x);
        }
      }
      return results;
    };
    join = function(list) {
      return list.join('_');
    };
    self = this;
    step(function*(resume) {
      var chunk, i, j, k, len, len1, len2, line, lines, matcher, probe, ref;
      for (i = 0, len = probes_and_matchers.length; i < len; i++) {
        [probe, matcher] = probes_and_matchers[i];
        urge(rpr(probe));
        lines = (yield FM.LEXER.lex(probe, resume));
        for (j = 0, len1 = lines.length; j < len1; j++) {
          line = lines[j];
          info(line.y, rpr(line.image));
          whisper(rainbow((function() {
            var k, len2, ref, results;
            ref = line.chunks;
            results = [];
            for (k = 0, len2 = ref.length; k < len2; k++) {
              chunk = ref[k];
              results.push(chunk.target);
            }
            return results;
          })()));
          ref = line.chunks;
          for (k = 0, len2 = ref.length; k < len2; k++) {
            chunk = ref[k];
            help('  ' + JSON.stringify(chunk));
          }
        }
      }
      T.end();
      return null;
    });
    return null;
  });

  TAP.test("stress test", function(T) {

    /* TAINT unfinished */
    T.end();
    return null;

    /*
    path = PATH.resolve __dirname, '../../../mingkwai-rack/jizura-datasources/data/flat-files/shape/shape-breakdown-formula.txt'
    pipeline = []
    pipeline.push input   = PS.new_file_source path
    pipeline.push FM.LEXER.$lex()
     * pipeline.push PS.$show()
    pipeline.push do ->
      count = 0
      return PS.map ( data ) ->
        help count if ( count += +1 ) % 1e4 is 0
        return data
    pipeline.push PS.map ( event ) -> event.target + '\n'
     * pipeline.push PS.map ( data ) -> ( JSON.stringify data ) + '\n'
    pipeline.push output  = PS.new_file_sink '/tmp/x'
     * pipeline.push PS.$drain()
    output.on 'finish', -> T.end()
    PS.pull pipeline...
     */
  });

}).call(this);

//# sourceMappingURL=splitting-with-uprops.js.map
