// Generated by CoffeeScript 2.0.0-beta2
(function() {
  var TAP, _;

  TAP = require('tap');

  TAP.test("skip", function(T) {
    T.end();
    return null;
  });

  _ = function() {
    var LTSORT, XXX, description, entries, f, graph, i, key, len, ref1, show;
    FM['has-transforms'] = true;
    FM.LEXER['has-transforms'] = true;
    this.walk_transforms = function(root, prefix = null) {
      return this._walk_transforms(root, prefix, {});
    };
    this._walk_transforms = function(root, prefix = null, R) {
      var description, descriptor, key, method, name, path, ref1, type;
      if (prefix != null) {
        if (!CND.isa_list(prefix)) {
          prefix = [prefix];
        }
      } else {
        prefix = [];
      }
      ref1 = Object.getOwnPropertyDescriptors(root);
      for (name in ref1) {
        descriptor = ref1[name];
        ({
          value: method
        } = descriptor);
        switch (type = CND.type_of(method)) {
          case 'pod':
            if (!method['has-transforms']) {
              continue;
            }
            prefix.push(name);
            return this._walk_transforms(method, prefix, R);
            prefix.pop();
            break;
          case 'function':
            if (!name.startsWith('$')) {
              continue;
            }
            key = name.slice(1).replace(/_/g, '-');
            path = PATH.join(...prefix, key);
            ({description} = method);
            if (description == null) {
              description = {};
            }
            R[path] = {method, description};
        }
      }
      return R;
    };
    debug('89883', this.walk_transforms(FM, 'FM'));
    debug('89883', FM);
    LTSORT = require('ltsort');
    f = function() {
      this.new_graph = function(prefix) {
        var R;
        R = LTSORT.new_graph({
          loners: false

          /* TAINT use library-specific symbol */
        });
        R['%prefix'] = prefix != null ? prefix : '';
        R['%attachments'] = {};
        return R;
      };
      this.attach = function(me, need, key) {
        var base, ref, target;
        need = this._resolve_path(me, need);
        ref = this._resolve_path(me, key);
        target = (base = me['%attachments'])[need] != null ? base[need] : base[need] = [];
        target.push(key);
        return null;
      };
      this._resolve_path = function(me, key) {
        var R, prefix;
        prefix = me['%prefix'];
        R = PATH.resolve('/', me['%prefix'], key);
        if (!PATH.isAbsolute(prefix)) {
          R = PATH.relative('/', R);
        }
        return R;
      };
      this.add = function(me, key, description) {
        var consequent, feed, feeds, i, j, len, len1, need, needs, precedent, ref;
        needs = null;
        feeds = null;
        if (description != null) {
          ({needs, feeds} = description);
        }
        if (needs == null) {
          needs = [];
        }
        if (feeds == null) {
          feeds = [];
        }
        needs = this._pluralize(null, needs);
        feeds = this._pluralize(null, feeds);
        needs = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = needs.length; i < len; i++) {
            need = needs[i];
            results.push(this._resolve_path(me, need));
          }
          return results;
        }).call(this);
        feeds = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = feeds.length; i < len; i++) {
            feed = feeds[i];
            results.push(this._resolve_path(me, feed));
          }
          return results;
        }).call(this);
        ref = this._resolve_path(me, key);
        this._add_start_and_stop(me, ref);
        this._add_start_and_stop(me, needs);
        this._add_start_and_stop(me, feeds);
        for (i = 0, len = needs.length; i < len; i++) {
          precedent = needs[i];
          LTSORT.add(me, precedent, ref);
        }
        for (j = 0, len1 = feeds.length; j < len1; j++) {
          consequent = feeds[j];
          LTSORT.add(me, ref, consequent);
        }
        return null;
      };
      this._pluralize = function(_, x) {
        if (CND.isa_list(x)) {
          return x;
        } else {
          return [x];
        }
      };
      this._add_start_and_stop = function(me, path_or_paths) {
        var i, len, path, paths;
        paths = this._pluralize(null, path_or_paths);
        for (i = 0, len = paths.length; i < len; i++) {
          path = paths[i];
          if (path !== '~START') {
            LTSORT.add(me, '~START', path);
          }
          if (path !== '~STOP') {
            LTSORT.add(me, path, '~STOP');
          }
        }
        return null;
      };

      /* TAINT should honor result of `@group` method */
      this.get_linearity = function(me, ...P) {
        return LTSORT.get_linearity(me, ...P);
      };
      this.group = function(me, ...P) {

        /* TAINT should only push attachments to current group when group length > 1 */
        var R, attachment, attachments, group, groups, i, j, k, len, len1, len2, ref, target;
        groups = LTSORT.group(me, ...P);
        R = [];
        for (i = 0, len = groups.length; i < len; i++) {
          group = groups[i];
          target = [];
          R.push(target);
          for (j = 0, len1 = group.length; j < len1; j++) {
            ref = group[j];
            target.push(ref);

            /* TAINT code duplication */
            if ((attachments = me['%attachments'][ref]) == null) {
              continue;
            }
            for (k = 0, len2 = attachments.length; k < len2; k++) {
              attachment = attachments[k];
              target.push(attachment);
            }
          }
        }
        return R;
      };
      return this.linearize = function(me, ...P) {
        var R, attachment, attachments, i, j, len, len1, ref, refs;
        refs = LTSORT.linearize(me, ...P);
        R = [];
        for (i = 0, len = refs.length; i < len; i++) {
          ref = refs[i];
          R.push(ref);

          /* TAINT code duplication */
          if ((attachments = me['%attachments'][ref]) == null) {
            continue;
          }
          for (j = 0, len1 = attachments.length; j < len1; j++) {
            attachment = attachments[j];
            R.push(attachment);
          }
        }
        return R;
      };
    };
    f.apply(XXX = {});
    entries = [
      ['LEXER/as-lines'], [
        'LEXER/as-characters', {
          needs: 'LEXER/as-lines'
        }
      ], [
        'LEXER/add-uccs', {
          needs: 'LEXER/as-characters'
        }
      ], [
        'LEXER/rewrite-lws', {
          needs: 'LEXER/add-uccs',
          feeds: 'LEXER/group-by-ucc'
        }
      ], [
        'LEXER/group-by-ucc', {
          needs: 'LEXER/add-uccs'
        }
      ], [
        'LEXER/join-groups', {
          needs: 'LEXER/group-by-ucc'
        }
      ]
    ];
    show = function(graph) {
      var group, i, j, key, len, len1, ref1, ref2;
      ref1 = XXX.linearize(graph);
      for (i = 0, len = ref1.length; i < len; i++) {
        key = ref1[i];
        help(key);
      }
      ref2 = XXX.group(graph);
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        group = ref2[j];
        info(group);
      }
      return info(XXX.get_linearity(graph));
    };
    graph = XXX.new_graph('FM');
    ref1 = CND.shuffle(entries);
    for (i = 0, len = ref1.length; i < len; i++) {
      [key, description] = ref1[i];
      XXX.add(graph, key, description);
    }
    show(graph);
    XXX.attach(graph, 'LEXER/rewrite-lws', '/PS/show');
    return show(graph);
  };

}).call(this);

//# sourceMappingURL=dependency-graphs.js.map
