// Generated by CoffeeScript 2.0.0-alpha1
(function() {
  var $, CND, CS, FLOWMATIC, PS, badge, debug, map, rpr;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'FLOWMATIC/PROTOCOL';

  debug = CND.get_logger('debug', badge);

  PS = require('../../pipestreams');

  $ = PS.$, map = PS.map;

  CS = require('coffeescript');

  FLOWMATIC = require('..');

  this.$transpile_to_cs_tokens = function() {
    var pipeline;
    pipeline = [];
    pipeline.push(this._$translate_slashdot());
    pipeline.push(this._$translate_dashed_identifier());
    return PS.pull(...pipeline);
  };

  this.$cs_tokens_as_text = function() {
    var pipeline;
    pipeline = [];
    pipeline.push(map(function(token) {
      var cs, image;
      image = token.image, cs = token.cs;
      return cs != null ? cs : image;
    }));
    pipeline.push(PS.$join());
    return PS.pull(...pipeline);
  };

  this.$cs_text_as_js = function() {
    return map(function(cs_text) {
      return CS.compile(cs_text);
    });
  };

  this.$cs_tokens_as_protocol_A = function() {
    var collector;
    collector = [];
    return $('null', function(token, send) {
      var image, start, stop, type;
      if (token != null) {
        start = token.start, stop = token.stop, type = token.type, image = token.image;
        collector.push(`${start}:${stop},${type},${rpr(image)}`);
      } else {
        send(collector.join('\n'));
      }
      return null;
    });
  };

  this.$cs_tokens_as_protocol_B = function() {
    var collector, level, line;
    collector = [];
    line = [];
    level = 0;
    return $('null', function(token, send) {
      var image, type;
      if (token != null) {
        type = token.type, image = token.image;
        switch (type) {
          case 'stop':
            if (line.length > 0) {
              collector.push(line.join(' '));
            }
            line.length = 0;
            break;
          case 'nl':
            collector.push(line.join(' '));
            line.length = 0;
            break;
          case 'indent':
            line.push('>');
            break;
          case 'dedent':
            line.push('<');
            break;
          case 'indentation':
          case 'start':
            null;
            break;
          default:
            line.push(`(${type}|${rpr(image)})`);
        }
      } else {
        send(collector.join('\n'));
      }
      return null;
    });
  };

  this.$show = function() {
    return map(function(token) {
      var color, cs, cs_txt, image, isxid, level, level_txt, padding, start, stop, type;
      start = token.start, stop = token.stop, type = token.type, image = token.image, isxid = token.isxid, cs = token.cs, level = token.level;
      start = rpr(start);
      while (start.length < 3) {
        start = ' ' + start;
      }
      stop = rpr(stop);
      while (stop.length < 3) {
        stop = ' ' + stop;
      }
      padding = ' '.repeat(20 - type.length);
      cs_txt = '';
      level_txt = '';
      switch (false) {
        case type !== 'indent' && type !== 'dedent':
          color = CND.steel;
          break;
        case type !== 'lws' && type !== 'nl' && type !== 'space' && type !== 'indentation':
          color = CND.grey;
          break;
        case isxid !== true:
          color = CND.orange;
          break;
        default:
          color = CND.blue;
      }
      if (cs != null) {
        cs_txt = `${CND.grey('->')} ${CND.red(rpr(cs))}`;
      }
      if (type === 'indent' || type === 'dedent') {
        level_txt = `level: ${CND.red(rpr(level))}`;
      }
      info(color(`${start}:${stop} ${type}${padding} ${rpr(image)} ${cs_txt} ${level_txt}`));
      return token;
    });
  };

}).call(this);

//# sourceMappingURL=protocol.js.map
