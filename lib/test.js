// Generated by CoffeeScript 1.7.1
(function() {
  var BNP, ESCODEGEN, LOADER, TRM, alert, assert, badge, debug, echo, escodegen_options, help, info, log, njs_path, praise, rpr, urge, warn, whisper,
    __slice = [].slice;

  njs_path = require('path');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾test﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  LOADER = require('./LOADER');

  assert = require('assert');

  BNP = require('coffeenode-bitsnpieces');

  ESCODEGEN = require('escodegen');

  escodegen_options = (require('../options'))['escodegen'];

  this.test = {
    ok: (function(_this) {
      return function(result) {

        /* Tests whether `result` is strictly `true` (not only true-ish). */
        if (result !== true) {
          throw new Error("expected true, got\n" + (rpr(result)));
        }
      };
    })(this),
    fail: (function(_this) {
      return function(message) {
        throw new Error(message);
      };
    })(this),
    eq: (function(_this) {
      return function() {
        var P, p;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

        /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
        for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
        worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
        as they use JavaScript's broken `==` equality operator instead of `===`.
         */
        if (!BNP.equals.apply(BNP, P)) {
          throw new Error("not equal: \n" + (((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = P.length; _i < _len; _i++) {
              p = P[_i];
              _results.push(JSON.stringify(p));
            }
            return _results;
          })()).join('\n')));
        }
      };
    })(this),
    as_js: (function(_this) {
      return function(node) {

        /* Given a SpiderMonkey Parser API-compliant `node` object, returns the corresponding JavaScript
        source code as results from applying EsCodeGen (with the settings as detailed in `options.coffee`);
        this is handy to do a quick sanity check on expected translation results.
         */
        return ESCODEGEN.generate(node, escodegen_options);
      };
    })(this),
    throws: assert.throws.bind(assert)
  };

  this._matches_filter = function(nr, module_name, matchers) {
    var matcher, _i, _len;
    if (matchers.length === 0) {
      return nr !== 0;
    }
    for (_i = 0, _len = matchers.length; _i < _len; _i++) {
      matcher = matchers[_i];
      if (matcher === ("" + nr)) {
        return true;
      }
      if ((matcher.test != null) && matcher.test(module_name)) {
        return true;
      }
    }
    return false;
  };

  this.main = function() {
    var TESTS, error, fail_count, idx, locator, m, matchers, miss_count, module, module_name, nr, pass_count, route, route_count, route_info, route_infos, skip_count, test_count, test_name, _i, _j, _len, _len1;
    route_infos = LOADER.get_route_infos({
      all: true
    });
    route_count = route_infos.length;
    skip_count = 0;
    test_count = 0;
    pass_count = 0;
    fail_count = 0;
    miss_count = 0;
    matchers = process.argv.slice(2);
    if (matchers.length !== 0) {
      whisper("matching modules with " + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = matchers.length; _i < _len; _i++) {
          m = matchers[_i];
          _results.push(rpr(m));
        }
        return _results;
      })()).join(', ')));
    }
    for (idx = _i = 0, _len = matchers.length; _i < _len; idx = ++_i) {
      m = matchers[idx];
      if (!/^[0-9]+$/.test(m)) {
        if (m === '+') {
          m = /.*/;
        } else {
          m = new RegExp(".*" + (BNP.escape_regex(m)) + ".*", 'i');
        }
      }
      matchers[idx] = m;
    }
    whisper(matchers);
    for (_j = 0, _len1 = route_infos.length; _j < _len1; _j++) {
      route_info = route_infos[_j];
      route = route_info.route, module_name = route_info.name, nr = route_info.nr;
      if (!this._matches_filter(nr, module_name, matchers)) {
        whisper("skipping " + nr + "-" + module_name);
        skip_count += 1;
        continue;
      }
      info((rpr(nr)) + '-' + module_name);
      module = require(route);
      if ((TESTS = module['$TESTS']) == null) {
        miss_count += 1;
        urge("no tests found for " + nr + "-" + module_name + " (" + route + ")");
        continue;
      }
      for (test_name in TESTS) {
        test_count += 1;
        locator = (rpr(nr)) + '-' + module_name + '/' + test_name;
        try {
          TESTS[test_name].call(module, this.test);
        } catch (_error) {
          error = _error;
          fail_count += 1;
          warn("" + locator + ":");
          warn(error['message']);
          continue;
        }
        pass_count += 1;
        praise("" + locator);
      }
    }
    whisper('-------------------------------------------------------------');
    info("Skipped " + skip_count + " out of " + route_count + " modules;");
    info("of the " + (route_count - skip_count) + " modules inspected,");
    urge("" + miss_count + " modules had no test cases.");
    info("In the remaining " + (route_count - miss_count - skip_count) + " modules,");
    info("" + test_count + " tests were performed,");
    praise("of which " + pass_count + " tests passed,");
    warn("and " + fail_count + " tests failed.");
    whisper('-------------------------------------------------------------');
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
