// Generated by CoffeeScript 1.6.3
(function() {
  var BNP, ESCODEGEN, LOADER, NEW, TRM, alert, assert, badge, debug, echo, escodegen_options, help, info, log, njs_path, praise, rpr, urge, warn, whisper,
    _this = this,
    __slice = [].slice;

  njs_path = require('path');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾test﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  NEW = require('./NEW');

  LOADER = require('./grammar-loader');

  assert = require('assert');

  BNP = require('coffeenode-bitsnpieces');

  ESCODEGEN = require('escodegen');

  escodegen_options = (require('../options'))['escodegen'];

  this.test = {
    ok: function(result) {
      /* Tests whether `result` is strictly `true` (not only true-ish).*/

      if (result !== true) {
        throw new Error("expected true, got\n" + (rpr(result)));
      }
    },
    fail: function(message) {
      throw new Error(message);
    },
    eq: function() {
      var P, p;
      P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
      for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
      worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
      as they use JavaScript's broken `==` equality operator instead of `===`.
      */

      if (!BNP.equals.apply(BNP, P)) {
        throw new Error("not equal: \n" + (((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = P.length; _i < _len; _i++) {
            p = P[_i];
            _results.push(JSON.stringify(p));
          }
          return _results;
        })()).join('\n')));
      }
    },
    as_js: function(node) {
      /* Given a SpiderMonkey Parser API-compliant `node` object, returns the corresponding JavaScript
      source code as results from applying EsCodeGen (with the settings as detailed in `options.coffee`);
      this is handy to do a quick sanity check on expected translation results.
      */

      return ESCODEGEN.generate(node, escodegen_options);
    },
    throws: assert.throws.bind(assert)
  };

  this._matches_filter = function(nr, module_name, matchers) {
    var matcher, _i, _len;
    if (matchers.length === 0) {
      return true;
    }
    for (_i = 0, _len = matchers.length; _i < _len; _i++) {
      matcher = matchers[_i];
      if (matcher === ("" + nr)) {
        return true;
      }
      if ((matcher.test != null) && matcher.test(module_name)) {
        return true;
      }
    }
    return false;
  };

  this.main = function() {
    var TESTS, error, fail_count, locator, m, matchers, miss_count, module, module_name, nr, pass_count, route, route_count, route_info, route_infos, skip_count, test_count, test_name, _i, _j, _len, _len1, _ref;
    route_infos = LOADER.get_route_infos({
      all: true
    });
    route_count = route_infos.length;
    skip_count = 0;
    test_count = 0;
    pass_count = 0;
    fail_count = 0;
    miss_count = 0;
    matchers = [];
    _ref = process.argv.slice(2);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      if (!/^[0-9]+$/.test(m)) {
        m = new RegExp(".*" + (BNP.escape_regex(m)) + ".*");
      }
      matchers.push(m);
    }
    for (_j = 0, _len1 = route_infos.length; _j < _len1; _j++) {
      route_info = route_infos[_j];
      route = route_info.route, module_name = route_info.name, nr = route_info.nr;
      if (!this._matches_filter(nr, module_name, matchers)) {
        whisper("skipping " + nr + "-" + module_name);
        skip_count += 1;
        continue;
      }
      info((rpr(nr)) + '-' + module_name);
      module = require(route);
      if ((TESTS = module['$TESTS']) == null) {
        miss_count += 1;
        urge("no tests found for " + nr + "-" + module_name + " (" + route + ")");
        continue;
      }
      for (test_name in TESTS) {
        test_count += 1;
        locator = (rpr(nr)) + '-' + module_name + '/' + test_name;
        try {
          TESTS[test_name].call(module, this.test);
        } catch (_error) {
          error = _error;
          fail_count += 1;
          warn("" + locator + ":");
          warn(error['message']);
          continue;
        }
        pass_count += 1;
        praise("" + locator);
      }
    }
    whisper('-------------------------------------------------------------');
    info("Skipped " + skip_count + " out of " + route_count + " modules;");
    info("of the " + (route_count - skip_count) + " modules inspected,");
    urge("" + miss_count + " modules had no test cases.");
    info("In the remaining " + (route_count - miss_count - skip_count) + " modules,");
    info("" + test_count + " tests were performed,");
    praise("of which " + pass_count + " tests passed,");
    warn("and " + fail_count + " tests failed.");
    whisper('-------------------------------------------------------------');
    return null;
  };

  if (module.parent == null) {
    this.main();
  }

}).call(this);
