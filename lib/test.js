// Generated by CoffeeScript 1.7.1
(function() {
  var BNP, LOADER, TRM, alert, assert, badge, debug, docopt, echo, help, info, log, njs_path, praise, rpr, urge, usage, warn, whisper,
    __slice = [].slice;

  njs_path = require('path');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾test﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  LOADER = require('./LOADER');

  assert = require('assert');

  docopt = (require('docopt')).docopt;

  BNP = require('coffeenode-bitsnpieces');

  this["new"] = require('./new');

  this.cl_options = null;

  this.test = {
    ok: (function(_this) {
      return function(result) {

        /* Tests whether `result` is strictly `true` (not only true-ish). */
        if (result !== true) {
          throw new Error("expected true, got\n" + (rpr(result)));
        }
      };
    })(this),
    fail: (function(_this) {
      return function(message) {
        throw new Error(message);
      };
    })(this),
    eq: (function(_this) {
      return function() {
        var P, p, values, _i, _len;
        P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

        /* Tests whether all arguments are pairwise and deeply equal. Uses CoffeeNode Bits'n'Pieces' `equal`
        for testing as (1) Node's `assert` distinguishes—unnecessarily—between shallow and deep equality, and,
        worse, [`assert.equal` and `assert.deepEqual` are broken](https://github.com/joyent/node/issues/7161),
        as they use JavaScript's broken `==` equality operator instead of `===`.
         */
        values = [];
        for (_i = 0, _len = P.length; _i < _len; _i++) {
          p = P[_i];
          _this["new"]._delete_grammar_references(p);
          values.push(rpr(p));
        }
        if (!BNP.equals.apply(BNP, P)) {
          throw new Error("not equal: \n" + (values.join('\n')));
        }
      };
    })(this),
    throws: assert.throws.bind(assert)
  };

  this._matches_filter = function(nr, module_name, hints) {
    var hint, _i, _len;
    if (hints.length === 0) {
      return nr !== 0;
    }
    for (_i = 0, _len = hints.length; _i < _len; _i++) {
      hint = hints[_i];
      if (hint === ("" + nr)) {
        return true;
      }
      if ((hint.test != null) && hint.test(module_name)) {
        return true;
      }
    }
    return false;
  };

  this.main = function() {
    var TESTS, error, fail_count, hints, idx, locator, m, miss_count, module, module_name, nr, pass_count, route, route_count, route_info, route_infos, skip_count, test_count, test_name, test_names, _i, _j, _k, _len, _len1, _len2, _ref;
    route_infos = LOADER.get_route_infos({
      'is-tty': true
    });
    route_count = route_infos.length;
    skip_count = 0;
    test_count = 0;
    pass_count = 0;
    fail_count = 0;
    miss_count = 0;
    hints = this.cl_options['<hints>'];
    if (hints.length !== 0) {
      whisper("matching modules with " + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = hints.length; _i < _len; _i++) {
          m = hints[_i];
          _results.push(rpr(m));
        }
        return _results;
      })()).join(', ')));
    }
    for (idx = _i = 0, _len = hints.length; _i < _len; idx = ++_i) {
      m = hints[idx];
      if (!/^[0-9]+$/.test(m)) {
        if (m === '+') {
          m = /.*/;
        } else {
          m = new RegExp(".*" + (BNP.escape_regex(m)) + ".*", 'i');
        }
      }
      hints[idx] = m;
    }
    for (_j = 0, _len1 = route_infos.length; _j < _len1; _j++) {
      route_info = route_infos[_j];
      route = route_info.route, module_name = route_info.name, nr = route_info.nr;
      if (!this._matches_filter(nr, module_name, hints)) {
        whisper("skipping " + nr + "-" + module_name);
        skip_count += 1;
        continue;
      }
      info((rpr(nr)) + '-' + module_name);
      module = require(route);

      /* TAINT reference to `$TESTS` to be removed */
      TESTS = (_ref = module['$TESTS']) != null ? _ref : module['tests'];
      if (!((TESTS != null) && (test_names = (function() {
        var _results;
        _results = [];
        for (test_name in TESTS) {
          _results.push(test_name);
        }
        return _results;
      })()).length > 0)) {
        miss_count += 1;
        urge("no tests found for " + nr + "-" + module_name + " (" + route + ")");
        continue;
      }
      for (_k = 0, _len2 = test_names.length; _k < _len2; _k++) {
        test_name = test_names[_k];
        if (test_name[0] === '_') {
          continue;
        }
        test_count += 1;
        locator = (rpr(nr)) + '-' + module_name + '/' + test_name;
        try {
          TESTS[test_name].call(module, this.test);
        } catch (_error) {
          error = _error;
          fail_count += 1;
          warn("" + locator + ":");
          if (this.cl_options['--long-errors']) {
            warn(error['stack']);
          } else {
            warn(error['message']);
          }
          continue;
        }
        pass_count += 1;
        praise("" + locator);
      }
    }
    whisper('-------------------------------------------------------------');
    info("Skipped " + skip_count + " out of " + route_count + " modules;");
    info("of the " + (route_count - skip_count) + " modules inspected,");
    urge("" + miss_count + " modules had no test cases.");
    info("In the remaining " + (route_count - miss_count - skip_count) + " modules,");
    info("" + test_count + " tests were performed,");
    praise("of which " + pass_count + " tests passed,");
    warn("and " + fail_count + " tests failed.");
    whisper('-------------------------------------------------------------');
    return null;
  };

  if (module.parent == null) {
    usage = "Usage: test [options] [<hints>]...\n\nOptions:\n  -l, --long-errors       Show error messages with stacks.\n  -h, --help\n  -v, --version";
    this.cl_options = docopt(usage, {
      version: (require('../package.json'))['version']
    });
    this.main();
  }

}).call(this);
