// Generated by CoffeeScript 1.12.6
(function() {
  var $, CND, CS, FLOWMATIC, PS, SourceType, alert, badge, debug, echo, help, info, lex, log, map, ref, rpr, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'DEMO-COFFEE-LEX';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  PS = require('pipestreams');

  $ = PS.$, map = PS.map;

  CS = require('coffeescript');

  FLOWMATIC = require('..');

  ref = require('stupid-coffee-lexer'), lex = ref["default"], SourceType = ref.SourceType;

  this._image_from_section = function(section) {
    var token;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = section.length; i < len; i++) {
        token = section[i];
        results.push(token.image);
      }
      return results;
    })()).join('');
  };

  this._typeimage_from_section = function(section) {
    var token;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = section.length; i < len; i++) {
        token = section[i];
        results.push(token.type);
      }
      return results;
    })()).join(',');
  };

  this.$exponentiation = function() {
    return PS.$gliding_window(4, (function(_this) {
      return function(section) {
        var image, ref1;
        image = _this._image_from_section(section);
        if (image === ' ** ') {

          /* TAINT use proper method */
          [].splice.apply(section, [1, 2].concat(ref1 = {
            type: 'operator',
            start: 0,
            stop: 0,
            image: '**',
            specifier: 'operator/**'
          })), ref1;
        }
        return null;
      };
    })(this));
  };

  this.$xidentifiers = function() {
    var flush, id_collector, id_start, send;
    send = null;
    id_collector = [];
    id_start = null;
    flush = function() {
      var id_count, image, stop;
      if ((id_count = id_collector.length) > 0) {
        image = id_collector.join('');
        stop = id_start + id_count;
        send({
          start: id_start,
          stop: stop,
          type: 'identifier',
          image: image,
          isxid: true,
          count: id_count
        });
        id_collector.length = 0;
        id_start = null;
      }
      return null;
    };
    return $('null', (function(_this) {
      return function(token, send_) {
        var image, isxid, start;
        send = send_;
        if (token != null) {
          image = token.image, start = token.start, isxid = token.isxid;
          if (isxid) {
            if (id_start == null) {
              id_start = start;
            }
            id_collector.push(image);
          } else {
            flush();
            send(token);
          }
        } else {
          flush();
        }
        return null;
      };
    })(this));
  };

  this.$relabel_slash = function() {
    return map((function(_this) {
      return function(token) {
        if (token.image === '/') {
          token.type = 'slash';
        }
        return token;
      };
    })(this));
  };

  this.$slash_as_dot = function() {
    return PS.$gliding_window(3, (function(_this) {
      return function(section) {
        var typeimage;
        typeimage = _this._typeimage_from_section(section);
        if (typeimage === 'identifier,slash,identifier') {
          section[1].type = 'slashdot';
        }
        return null;
      };
    })(this));
  };

  this.$number_with_underscores = function() {

    /* acc. to http://www.regular-expressions.info/floatingpoint.html */
    var pattern;
    pattern = /^_[_0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?$/;
    return PS.$gliding_window(2, (function(_this) {
      return function(section) {
        var blank, cs, image, isxid, new_token, start, stop, t0, t1, type, typeimage;
        typeimage = _this._typeimage_from_section(section);
        if (typeimage === 'number,identifier') {
          t0 = section[0], t1 = section[1];
          if (pattern.test(t1.image)) {
            start = t0.start;
            stop = t1.stop;
            image = t0.image + t1.image;
            cs = image.replace(/_/g, '');
            blank = false;
            isxid = false;
            type = 'number';
            new_token = {
              start: start,
              stop: stop,
              type: type,
              image: image,
              cs: cs,
              blank: blank,
              isxid: isxid
            };
            [].splice.apply(section, [0, 2].concat(new_token)), new_token;
          }
        }
        return null;
      };
    })(this));
  };

  this.$key_with_sigil = function() {
    var sigils;
    sigils = ['~', '%'];
    return PS.$gliding_window(4, (function(_this) {
      return function(section) {
        var blank, cs, image, isxid, new_token, ref1, start, stop, t0, t1, t2, t3, type;
        t0 = section[0], t1 = section[1], t2 = section[2], t3 = section[3];
        if ((ref1 = t0.image, indexOf.call(sigils, ref1) >= 0) && t1.type === 'identifier' && t2.image === ':' && t3.blank) {
          start = t0.start;
          stop = t1.stop;
          image = t0.image + t1.image;
          cs = rpr(image);
          blank = false;
          isxid = false;
          type = 'key';
          new_token = {
            start: start,
            stop: stop,
            type: type,
            image: image,
            cs: cs,
            blank: blank,
            isxid: isxid
          };
          [].splice.apply(section, [0, 2].concat(new_token)), new_token;
        }
        return null;
      };
    })(this));
  };

  this.$keystring = function() {
    var prv_blank;
    prv_blank = true;
    return PS.$gliding_window(3, (function(_this) {
      return function(section) {
        var blank, image, isxid, new_token, start, stop, t0, t1, t2, type;
        t0 = section[0], t1 = section[1], t2 = section[2];
        if (t0.blank && (t1.image === ':') && (t2.type === 'identifier')) {
          start = t1.start;
          stop = t2.stop;
          image = rpr(t2.image);
          blank = false;
          isxid = false;
          type = 'keystring';
          new_token = {
            start: start,
            stop: stop,
            type: type,
            image: image,
            blank: blank,
            isxid: isxid
          };
          [].splice.apply(section, [1, 2].concat(new_token)), new_token;
        }
        return null;
      };
    })(this));
  };

  this._$translate_slashdot = function() {
    return PS.$gliding_window(3, (function(_this) {
      return function(section) {
        var typeimage;
        typeimage = _this._typeimage_from_section(section);
        if (typeimage === 'identifier,slashdot,identifier') {
          section[1].type = 'dot';
          section[1].cs = '.';
        }
        return null;
      };
    })(this));
  };

  this._$translate_dashed_identifier = function() {
    return map(function(token) {
      var cs_image, image, type;
      type = token.type, image = token.image;
      if (type === 'identifier') {
        cs_image = image.replace(/-/g, '_');
        if (cs_image !== image) {
          token.cs = cs_image;
        }
      }
      return token;
    });
  };

  this.$transpile = function() {
    var pipeline, Ø;
    pipeline = [];
    Ø = (function(_this) {
      return function(x) {
        return pipeline.push(x);
      };
    })(this);
    Ø(this.$exponentiation());
    Ø(this.$xidentifiers());
    Ø(this.$key_with_sigil());
    Ø(this.$keystring());
    Ø(this.$relabel_slash());
    Ø(this.$slash_as_dot());
    Ø(this.$number_with_underscores());
    return PS.pull.apply(PS, pipeline);
  };

}).call(this);

//# sourceMappingURL=basic-arabika.js.map
