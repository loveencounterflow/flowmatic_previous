// Generated by CoffeeScript 1.6.3
/* TAINT this module could form a separate package*/


/* Reads the SpiderMonkey Parser API Type Hierarchy as recorded in `../options.coffee` and constructs a
graph-like structure that gives answers to such questions as 'is a YieldExpression an Expression?' (yes) or
'is a SwitchCase node a Statement? an Expression?' (no and no).
*/


(function() {
  var TRM, alert, badge, debug, echo, g, help, info, log, new_dependencies_graph, new_tsort_graph, rainbow, raw_dependencies, rpr, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'tsort';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  raw_dependencies = (require('../options'))['parserapi']['dependencies'];

  new_tsort_graph = require('tsort');

  new_dependencies_graph = function() {
    var R, ancestor, ancestors, ancestors_list, descendant, g, ignored, match, matcher, predecessor, raw_dependency, rhs, splitter, _i, _j, _k, _len, _len1, _len2, _ref;
    matcher = /^\s*([^\s<]+)\s*<?\s*(.*)$/;
    splitter = /\s*,\s*/;
    g = new_tsort_graph();
    R = {};
    for (_i = 0, _len = raw_dependencies.length; _i < _len; _i++) {
      raw_dependency = raw_dependencies[_i];
      match = raw_dependency.match(matcher);
      if (match == null) {
        throw new Error("syntax error: " + (rpr(raw_dependency)));
      }
      ignored = match[0], descendant = match[1], rhs = match[2];
      ancestors_list = (function() {
        var _j, _len1, _ref, _results;
        _ref = rhs.split(splitter);
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          ancestor = _ref[_j];
          if (ancestor.length > 0) {
            _results.push(ancestor);
          }
        }
        return _results;
      })();
      ancestors = {};
      R[descendant] = ancestors;
      for (_j = 0, _len1 = ancestors_list.length; _j < _len1; _j++) {
        ancestor = ancestors_list[_j];
        ancestors[ancestor] = 1;
        g.add(descendant, ancestor);
      }
    }
    _ref = g.sort().reverse();
    for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
      descendant = _ref[_k];
      for (ancestor in ancestors = R[descendant]) {
        for (predecessor in R[ancestor]) {
          ancestors[predecessor] = 1;
        }
      }
    }
    return R;
  };

  g = new_dependencies_graph();

  this.derives_from = function(descendant, ancestor) {
    var ancestors, predecessors;
    ancestors = g[descendant];
    predecessors = g[ancestor];
    if (ancestors == null) {
      throw new Error("unknown parser API type: " + (rpr(descendant)));
    }
    if (predecessors == null) {
      throw new Error("unknown parser API type: " + (rpr(ancestor)));
    }
    return ancestors[ancestor] != null;
  };

  this.isa_statement = function(node) {
    return this.derives_from(node['type'], 'Statement');
  };

  this.isa_expression = function(node) {
    return this.derives_from(node['type'], 'Expression');
  };

  if (module.parent == null) {
    log(this.derives_from('LetExpression', 'Node'));
    log(this.derives_from('LetExpression', 'Statement'));
    log(this.derives_from('ExpressionStatement', 'Statement'));
    log(this.derives_from('ExpressionStatement', 'Expression'));
    log(this.isa_expression({
      type: 'ExpressionStatement'
    }));
    log(this.isa_statement({
      type: 'ExpressionStatement'
    }));
    log(this.isa_statement({
      type: 'IfStatement'
    }));
    log(this.isa_statement({
      type: 'BlockStatement'
    }));
  }

}).call(this);
