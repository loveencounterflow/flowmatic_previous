// Generated by CoffeeScript 1.7.1
(function() {
  var PADAG, TRM, TYPES, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾new﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  PADAG = require('./PADAG');

  this["new"] = function(library) {
    return function(G, $) {
      var R, arity, get_rule, name, rule_name, value, _ref, _ref1, _ref2;
      if ((arity = arguments.length) === 1) {
        _ref = [null, G], G = _ref[0], $ = _ref[1];
      }
      if ($ == null) {
        $ = {};
      }
      _ref1 = library['$'];
      for (name in _ref1) {
        value = _ref1[name];
        if ($[name] == null) {
          $[name] = value;
        }
      }
      R = G != null ? G : {};
      R['$'] = $;
      _ref2 = library['$new'];
      for (rule_name in _ref2) {
        get_rule = _ref2[rule_name];
        if (R[rule_name] == null) {
          R[rule_name] = get_rule(R, $);
        }
      }
      return R;
    };
  };

  this.binary_expression = function(subtype, operator, left, right, verbatim) {
    var R;
    R = this._new_node('BinaryExpression', subtype, verbatim);
    R['operator'] = operator;
    R['left'] = left;
    R['right'] = right;
    return R;
  };

  this.expression_statement = function(subtype, expression, verbatim) {
    var R;
    R = this._new_node('ExpressionStatement', subtype, verbatim);
    R['expression'] = expression;
    return R;
  };

  this.block_statement = function(subtype, body, verbatim) {
    var R, idx, node, _i, _len;
    for (idx = _i = 0, _len = body.length; _i < _len; idx = ++_i) {
      node = body[idx];
      whisper('©521', node, idx);
      if (PADAG.isa_expression(node)) {
        body[idx] = this.expression_statement('auto', node);
      }
    }
    R = this._new_node('BlockStatement', subtype, verbatim);
    R['body'] = body;
    return R;
  };

  this.identifier = function(subtype, name, verbatim) {
    var R;
    R = this._new_node('Identifier', subtype, verbatim);
    R['name'] = name;
    return R;
  };

  this.literal = function(subtype, raw, value, verbatim) {
    var R;
    R = this._new_node('Literal', subtype, verbatim);
    R['raw'] = raw;
    R['value'] = value;
    return R;
  };

  this.x_comment = function(text, subtype) {
    if (subtype == null) {
      subtype = 'comment';
    }

    /* TAINT don't use `verbatim` here as it is target-language specific */
    return this.literal(subtype, text, text);
  };

  this.x_use_statement = function(keyword, argument) {
    var text;
    text = "" + keyword + " " + (rpr(argument));
    return this.x_comment(text, 'use-statement');
  };

  this._new_node = function(type, subtype, verbatim) {
    var R;
    R = {
      type: type,
      'x-subtype': subtype
    };
    if (verbatim != null) {
      R['x-verbatim'] = verbatim;
    }
    if (verbatim != null) {
      alert("use of verbatim feature discourage at this time: " + (rpr(verbatim)));
    }
    return R;
  };

  this._XXX_node = function(grammar, type, subtype) {

    /* TAINT method to replace `_new_node` */
    var R;
    R = {
      type: type,
      'x-subtype': subtype,
      'x-grammar': grammar
    };
    return R;
  };

  this._traverse = function(node, handler) {
    var ignored, sub_node, sub_sub_node, _i, _len;
    handler(node);
    for (ignored in node) {
      sub_node = node[ignored];
      if (!TYPES.isa_list(sub_node)) {
        continue;
      }
      for (_i = 0, _len = sub_node.length; _i < _len; _i++) {
        sub_sub_node = sub_node[_i];
        this._traverse(sub_node, handler);
      }
    }
    return null;
  };

  this._delete_grammar_references = function(node) {
    this._traverse(node, function(sub_node) {
      debug(node['type'], node['x-subtype']);
      debug(node['x-grammar'] != null);
      return delete node['x-grammar'];
    });
    return null;
  };

}).call(this);
