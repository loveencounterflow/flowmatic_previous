// Generated by CoffeeScript 1.7.1
(function() {
  var PADAG, TRM, TYPES, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾new﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  PADAG = require('./PADAG');

  this["new"] = function(library) {
    return function(G, $) {
      var R, arity, get_rule, name, rule_name, value, _ref, _ref1, _ref2;
      if ((arity = arguments.length) === 1) {
        _ref = [null, G], G = _ref[0], $ = _ref[1];
      }
      if ($ == null) {
        $ = {};
      }
      _ref1 = library['$'];
      for (name in _ref1) {
        value = _ref1[name];
        if ($[name] == null) {
          $[name] = value;
        }
      }
      R = G != null ? G : {};
      R['$'] = $;
      _ref2 = library['$new'];
      for (rule_name in _ref2) {
        get_rule = _ref2[rule_name];
        if (R[rule_name] == null) {
          if (TYPES.isa_function(get_rule)) {
            R[rule_name] = get_rule(R, $);
          } else {
            R[rule_name] = get_rule;
          }
        }
      }
      return R;
    };
  };

  this.binary_expression = function(subtype, operator, left, right, verbatim) {
    var R;
    R = this._new_node('BinaryExpression', subtype, verbatim);
    R['operator'] = operator;
    R['left'] = left;
    R['right'] = right;
    return R;
  };

  this.expression_statement = function(subtype, expression, verbatim) {
    var R;
    R = this._new_node('ExpressionStatement', subtype, verbatim);
    R['expression'] = expression;
    return R;
  };

  this.member_expression = function(subtype, computed, object, property, verbatim) {
    var R;
    R = this._new_node('MemberExpression', subtype, verbatim);
    R['computed'] = computed;
    R['object'] = object;
    R['property'] = property;
    return R;
  };

  this.block_statement = function(subtype, body, verbatim) {
    var R, idx, node, _i, _len;
    for (idx = _i = 0, _len = body.length; _i < _len; idx = ++_i) {
      node = body[idx];
      whisper('©521', node, idx);
      if (PADAG.isa_expression(node)) {
        body[idx] = this.expression_statement('auto', node);
      }
    }
    R = this._new_node('BlockStatement', subtype, verbatim);
    R['body'] = body;
    return R;
  };

  this.identifier = function(subtype, name, verbatim) {
    var R;
    R = this._new_node('Identifier', subtype, verbatim);
    R['name'] = name;
    return R;
  };

  this.literal = function(subtype, raw, value, verbatim) {
    var R;
    R = this._new_node('Literal', subtype, verbatim);
    R['raw'] = raw;
    R['value'] = value;
    return R;
  };

  this.x_comment = function(text, subtype) {
    if (subtype == null) {
      subtype = 'comment';
    }

    /* TAINT don't use `verbatim` here as it is target-language specific */
    return this.literal(subtype, text, text);
  };

  this.x_use_statement = function(keyword, argument) {
    var text;
    text = "" + keyword + " " + (rpr(argument));
    return this.x_comment(text, 'use-statement');
  };

  this._new_node = function(type, subtype, verbatim) {
    var R;
    R = {
      type: type,
      'x-subtype': subtype
    };
    if (verbatim != null) {
      R['x-verbatim'] = verbatim;
    }
    if (verbatim != null) {
      alert("use of verbatim feature discourage at this time: " + (rpr(verbatim)));
    }
    return R;
  };

  this._XXX_node = function(grammar, type, subtype) {

    /* TAINT method to replace `_new_node` */
    var R;
    R = {
      type: type,
      'x-subtype': subtype,
      'x-grammar': grammar
    };
    return R;
  };

  this._traverse = function(node, handler) {

    /* Traverse a node and all its sub-nodes. We can't use `estraverse` for this task as it does not reliably
    iterate over non-standard nodes.
     */
    var element, ignored, sub_node, type, _i, _len;
    switch (type = TYPES.type_of(node)) {
      case 'list':
        for (_i = 0, _len = node.length; _i < _len; _i++) {
          element = node[_i];
          this._traverse(element, handler);
        }
        break;
      case 'pod':
        if (node['type'] != null) {
          handler(node);
        }
        for (ignored in node) {
          sub_node = node[ignored];
          this._traverse(sub_node, handler);
        }
    }
    return null;
  };

  this._delete_grammar_references = function(node) {

    /* Remove references to issuing grammar from node, including nested sub-nodes; useful for testing. */
    this._traverse(node, function(sub_node) {
      return delete sub_node['x-grammar'];
    });
    return node;
  };

}).call(this);
