// Generated by CoffeeScript 1.7.1
(function() {
  var MULTIMIX, PADAG, TRM, alert, badge, debug, echo, help, info, log, rpr, warn, whisper;

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾new﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  MULTIMIX = require('coffeenode-multimix');

  PADAG = require('./PADAG');

  this["new"] = function(library) {
    return function(G, $) {
      var R, arity, get_rule, name, rule_name, value, _ref, _ref1, _ref2;
      if ((arity = arguments.length) === 1) {
        _ref = [null, G], G = _ref[0], $ = _ref[1];
      }
      if ($ == null) {
        $ = {};
      }
      _ref1 = library['$'];
      for (name in _ref1) {
        value = _ref1[name];
        if ($[name] == null) {
          $[name] = value;
        }
      }
      R = G != null ? G : {};
      R['$'] = $;
      _ref2 = library['$new'];
      for (rule_name in _ref2) {
        get_rule = _ref2[rule_name];
        if (R[rule_name] == null) {
          R[rule_name] = get_rule(R, $);
        }
      }
      return R;
    };
  };

  this.binary_expression = function(subtype, operator, left, right, verbatim) {
    var R;
    R = this._new_node('BinaryExpression', subtype, verbatim);
    R['operator'] = operator;
    R['left'] = left;
    R['right'] = right;
    return R;
  };

  this.expression_statement = function(subtype, expression, verbatim) {
    var R;
    R = this._new_node('ExpressionStatement', subtype, verbatim);
    R['expression'] = expression;
    return R;
  };

  this.block_statement = function(subtype, body, verbatim) {
    var R, idx, node, _i, _len;
    for (idx = _i = 0, _len = body.length; _i < _len; idx = ++_i) {
      node = body[idx];
      whisper('©521', node, idx);
      if (PADAG.isa_expression(node)) {
        body[idx] = this.expression_statement('auto', node);
      }
    }
    R = this._new_node('BlockStatement', subtype, verbatim);
    R['body'] = body;
    return R;
  };

  this.identifier = function(subtype, name, verbatim) {
    var R;
    R = this._new_node('Identifier', subtype, verbatim);
    R['name'] = name;
    return R;
  };

  this.literal = function(subtype, raw, value, verbatim) {
    var R;
    R = this._new_node('Literal', subtype, verbatim);
    R['raw'] = raw;
    R['value'] = value;
    return R;
  };

  this.x_comment = function(text, subtype) {
    if (subtype == null) {
      subtype = 'comment';
    }

    /* TAINT don't use `verbatim` here as it is target-language specific */
    return this.literal(subtype, text, text);
  };

  this.x_use_statement = function(keyword, argument) {
    var text;
    text = "" + keyword + " " + (rpr(argument));
    return this.x_comment(text, 'use-statement');
  };

  this.x_symbol = function(mark, raw, value) {
    var R;
    R = this._new_node('Literal', 'symbol');
    R['x-mark'] = mark;
    R['raw'] = raw;
    R['value'] = value;
    return R;
  };

  this.x_relative_route = function(raw, value) {
    var R;
    R = this._new_node('Literal', 'relative-route');
    R['raw'] = raw;
    R['value'] = value;
    return R;
  };

  this.x_identifier_with_sigil = function(sigil, name) {
    var R;
    R = this._new_node('Identifier', 'identifier-with-sigil');
    R['x-sigil'] = sigil;
    R['name'] = name;
    return R;
  };

  this.x_identifier_without_sigil = function(name) {
    var R;
    R = this._new_node('Identifier', 'identifier-without-sigil');
    R['name'] = name;
    return R;
  };

  this._new_node = function(type, subtype, verbatim) {
    var R;
    R = {
      type: type,
      'x-subtype': subtype
    };
    if (verbatim != null) {
      R['x-verbatim'] = verbatim;
    }
    if (verbatim != null) {
      alert("use of verbatim feature discourage at this time: " + (rpr(verbatim)));
    }
    return R;
  };

  this._add_verbatim = function(node, verbatim) {};

  MULTIMIX.bundle(this);

}).call(this);
