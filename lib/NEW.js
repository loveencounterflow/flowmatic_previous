// Generated by CoffeeScript 1.7.1
(function() {
  var LODASH, PADAG, TRM, TYPES, alert, badge, copy, debug, echo, help, info, log, rpr, warn, whisper;

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾new﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  PADAG = require('./PADAG');

  LODASH = require('lodash');

  copy = function(value) {

    /* Return a deep copy of `value`. */

    /* TAINT will fail silently for anything but lists and PODs */
    return LODASH.merge((TYPES.isa_list(value) ? [] : {}), value);
  };

  this["new"] = function(library) {
    return function(G, $) {
      var R, arity, get_rule, name, rule_name, value, _ref, _ref1, _ref2;
      if ((arity = arguments.length) === 1) {
        _ref = [null, G], G = _ref[0], $ = _ref[1];
      }
      if ($ == null) {
        $ = {};
      }
      _ref1 = library['$'];
      for (name in _ref1) {
        value = _ref1[name];
        if ($[name] == null) {
          $[name] = value;
        }
      }
      R = G != null ? G : {};
      R['$'] = $;
      _ref2 = library['$new'];
      for (rule_name in _ref2) {
        get_rule = _ref2[rule_name];
        if (R[rule_name] == null) {
          if (TYPES.isa_function(get_rule)) {
            R[rule_name] = get_rule(R, $);
          } else {
            R[rule_name] = get_rule;
          }
        }
      }
      return R;
    };
  };

  this.grammar = function(target, grammar, options) {

    /*
    
    call as:
      * `ƒ.new.grammar G` with a given grammar to instantiate a new grammar using default options. This
        should never be necessary for standard grammars (that have already instantiated themselves).
      * `ƒ.new.grammar G, $` with a grammar `G` and an options POD `$` to instantiate a grammar with rules
        as given by `G` and settings as given by `$`. This form may be used to obtain a 'parametrized
        modification' of `G`.
      * `ƒ.new.grammar target, G, $` with a `target` object, a grammar, and an options POD; this will
        add missing rules from `G` to `target` and preserve existing methods there. The third argument is
        mandatory to distinguish this signature from the one above, but may be set to `null`.
     */
    var arity, member, member_name, name, _ref, _ref1, _ref2, _ref3, _ref4;
    switch (arity = arguments.length) {
      case 1:
        _ref = [{}, target, {}], target = _ref[0], grammar = _ref[1], options = _ref[2];
        break;
      case 2:
        _ref1 = [{}, target, grammar], target = _ref1[0], grammar = _ref1[1], options = _ref1[2];
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected one, two or three arguments, got " + arity);
    }

    /* In case `G` has a member `grammar`, use that one instead of `G` itself; this allows us to derive
    new grammars by simply saying `ƒ.new.grammar ( require 'foo' ), options`:
     */
    if (grammar['grammar'] != null) {
      grammar = grammar['grammar'];
    }
    if (target['nodes'] == null) {
      target['nodes'] = {};
    }
    if (target['tests'] == null) {
      target['tests'] = {};
    }
    target['options'] = LODASH.merge((_ref2 = target['options']) != null ? _ref2 : {}, options != null ? options : {}, (_ref3 = grammar['options']) != null ? _ref3 : {});
    debug('###', (function() {
      var _results;
      _results = [];
      for (name in grammar) {
        _results.push(name);
      }
      return _results;
    })());
    debug('###', (function() {
      var _results;
      _results = [];
      for (name in grammar['options']) {
        _results.push(name);
      }
      return _results;
    })());
    debug('###', (function() {
      var _results;
      _results = [];
      for (name in options) {
        _results.push(name);
      }
      return _results;
    })());
    debug('###', (function() {
      var _results;
      _results = [];
      for (name in target['options']) {
        _results.push(name);
      }
      return _results;
    })());
    _ref4 = grammar(grammar(target, target['options']));
    for (member_name in _ref4) {
      member = _ref4[member_name];
      whisper(name);
    }
    return target;
  };

  this.consolidate = function(grammar) {
    var constructor, member, name, options, _ref, _results;
    if (grammar['nodes'] == null) {
      grammar['nodes'] = {};
    }
    if (grammar['tests'] == null) {
      grammar['tests'] = {};
    }
    constructor = grammar['constructor'];
    options = (_ref = grammar['options']) != null ? _ref : {};
    if (!TYPES.isa_function(constructor)) {
      throw new Error("unable to find constructor in grammar");
    }
    constructor(grammar, options);
    grammar.$ = options;
    _results = [];
    for (name in grammar) {
      member = grammar[name];
      if (name === 'constructor') {
        continue;
      }
      if (name === 'nodes') {
        continue;
      }
      if (name === 'tests') {
        continue;
      }
      if (name === 'options') {
        continue;
      }
      if (name === '$') {
        continue;
      }
      if (TYPES.isa_function(member)) {
        grammar[name] = member();
        _results.push(LODASH.merge(grammar[name], member));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  this.binary_expression = function(subtype, operator, left, right, verbatim) {
    var R;
    R = this._new_node('BinaryExpression', subtype, verbatim);
    R['operator'] = operator;
    R['left'] = left;
    R['right'] = right;
    return R;
  };

  this.expression_statement = function(subtype, expression, verbatim) {
    var R;
    R = this._new_node('ExpressionStatement', subtype, verbatim);
    R['expression'] = expression;
    return R;
  };

  this.member_expression = function(subtype, computed, object, property, verbatim) {
    var R;
    R = this._new_node('MemberExpression', subtype, verbatim);
    R['computed'] = computed;
    R['object'] = object;
    R['property'] = property;
    return R;
  };

  this.block_statement = function(subtype, body, verbatim) {
    var R, idx, node, _i, _len;
    for (idx = _i = 0, _len = body.length; _i < _len; idx = ++_i) {
      node = body[idx];
      whisper('©521', node, idx);
      if (PADAG.isa_expression(node)) {
        body[idx] = this.expression_statement('auto', node);
      }
    }
    R = this._new_node('BlockStatement', subtype, verbatim);
    R['body'] = body;
    return R;
  };

  this.identifier = function(subtype, name, verbatim) {
    var R;
    R = this._new_node('Identifier', subtype, verbatim);
    R['name'] = name;
    return R;
  };

  this.literal = function(subtype, raw, value, verbatim) {
    var R;
    R = this._new_node('Literal', subtype, verbatim);
    R['raw'] = raw;
    R['value'] = value;
    return R;
  };

  this.x_comment = function(text, subtype) {
    if (subtype == null) {
      subtype = 'comment';
    }

    /* TAINT don't use `verbatim` here as it is target-language specific */
    return this.literal(subtype, text, text);
  };

  this._new_node = function(type, subtype, verbatim) {
    var R;
    R = {
      type: type,
      'x-subtype': subtype
    };
    if (verbatim != null) {
      R['x-verbatim'] = verbatim;
    }
    if (verbatim != null) {
      alert("use of verbatim feature discourage at this time: " + (rpr(verbatim)));
    }
    return R;
  };

  this._XXX_node = function(grammar, type, subtype) {

    /* TAINT method to replace `_new_node` */
    var R;
    R = {
      type: type,
      'x-subtype': subtype,
      'x-grammar': grammar
    };
    return R;
  };

  this._XXX_YYY_node = function(translator, state, type, details) {

    /* TAINT method to replace `_new_node` */
    var R;
    R = {
      type: type,
      '%translator': translator
    };
    if (details != null) {
      LODASH.merge(R, details);
    }
    return R;
  };

  this._traverse = function(node, handler) {

    /* Traverse a node and all its sub-nodes. We can't use `estraverse` for this task as it does not reliably
    iterate over non-standard nodes.
     */
    var element, ignored, sub_node, type, _i, _len;
    switch (type = TYPES.type_of(node)) {
      case 'list':
        for (_i = 0, _len = node.length; _i < _len; _i++) {
          element = node[_i];
          this._traverse(element, handler);
        }
        break;
      case 'pod':
        if (node['type'] != null) {
          handler(node);
        }
        for (ignored in node) {
          sub_node = node[ignored];
          this._traverse(sub_node, handler);
        }
    }
    return null;
  };

  this._delete_grammar_references = function(node) {

    /* Remove references to issuing grammar from node, including nested sub-nodes; useful for testing. */

    /* TAINT fails to catch all subnodes; consider using CND Bits'N'Pieces traversal */
    this._traverse(node, function(sub_node) {
      delete sub_node['x-grammar'];
      delete sub_node['translator'];
      return delete sub_node['%translator'];
    });
    return node;
  };

}).call(this);
