// Generated by CoffeeScript 1.7.1
(function() {
  var MULTIMIX, TRM, alert, badge, debug, echo, help, info, log, njs_path, rainbow, rpr, warn, whisper, ƒ, π,
    __slice = [].slice;

  njs_path = require('path');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = '﴾main﴿';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  rainbow = TRM.rainbow.bind(TRM);

  this["new"] = require('./new');

  MULTIMIX = require('coffeenode-multimix');

  ƒ = this;

  π = require('coffeenode-packrattle');

  this.or = π.alt;

  this.chain = π.chain;

  this.check = π.check;

  this.commit = π.commit;

  this.consume = π.consume;

  this.drop = π.drop;

  this.end = π.end;

  this.not_ = π.not_;

  this.optional = π.optional;

  this.parse = π.parse;

  this.reduce = π.reduce;

  this.regex = π.regex;

  this.reject = π.reject;

  this.repeat = π.repeat;

  this.repeatIgnore = π.repeatIgnore;

  this.repeatSeparated = π.repeatSeparated;

  this.seq = π.seq;

  this.seqIgnore = π.seqIgnore;

  this.string = π.string;

  this.succeed = π.succeed;

  this.match = function(hint) {

    /* Convenience method to match either a text, a RegEx, or a deferred function. */
  };

  this.xre = function(hint) {};

  this.on = function(hint) {

    /* Method to replace `.onMatch` and `onFail`. */
  };

  this.as = function(target_language_name, node) {
    var translator;
    translator = this.as[target_language_name];
    if (translator == null) {
      throw new Error("unknown target language " + (rpr(target_language_name)));
    }
    return translator(node);
  };

  this.as._collect_taints = function() {
    var taint, taints, translation, translations, _i, _j, _len, _len1;
    translations = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    taints = {};
    for (_i = 0, _len = translations.length; _i < _len; _i++) {
      translation = translations[_i];
      if ((taints = translation['taints']) == null) {
        continue;
      }
      for (_j = 0, _len1 = taints.length; _j < _len1; _j++) {
        taint = taints[_j];
        taints[taint] = 1;
      }
    }
    return taints;
  };

  this.as.coffee = function(node) {

    /* TAINT call to grammar.as.coffee to be phased out */
    var grammar, taints, translator, type;
    if ((grammar = node['x-grammar']) != null) {
      return grammar.as.coffee(node);
    }
    if ((translator = node['translator']) != null) {
      return translator.coffee(node);
    }
    if ((translator = node['%translator']) != null) {
      return translator.coffee(node);
    }
    type = node['type'];
    if (node['x-subtype'] != null) {
      type += '/' + node['x-subtype'];
    }
    throw new Error("unable to find translator for " + type);
    taints = {};
    taints["unable to find translator for " + type] = 1;
    return {
      target: target,
      taints: taints
    };
  };

  this.as.coffee.target = function() {
    var R, taints, translation, translations, _i, _len, _ref;
    translations = 1 <= arguments.length ? __slice.call(arguments, 0) : [];

    /* TAINT what about indentation? */
    taints = (_ref = ƒ.as.coffee).taints.apply(_ref, translations);
    R = [taints];
    for (_i = 0, _len = translations.length; _i < _len; _i++) {
      translation = translations[_i];
      R.push(translation['target']);
    }
    return R.join('');
  };

  this.as.coffee.taints = function() {
    var taint, taints, translations, _ref;
    translations = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    taints = (_ref = ƒ.as)._collect_taints.apply(_ref, translations);
    taints = ((function() {
      var _results;
      _results = [];
      for (taint in taints) {
        _results.push(taint);
      }
      return _results;
    })()).sort();
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = taints.length; _i < _len; _i++) {
        taint = taints[_i];
        _results.push("### " + taint + " ###\n");
      }
      return _results;
    })()).join('');
  };

}).call(this);
